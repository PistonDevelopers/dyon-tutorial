<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Dyon Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="comments.html"><strong aria-hidden="true">3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">4.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mutability.html"><strong aria-hidden="true">4.1.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="named-arguments.html"><strong aria-hidden="true">4.2.</strong> Named arguments</a></li><li class="chapter-item expanded "><a href="return.html"><strong aria-hidden="true">4.3.</strong> Return</a></li></ol></li><li class="chapter-item expanded "><a href="blocks.html"><strong aria-hidden="true">5.</strong> Blocks</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">6.</strong> Variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="numbers.html"><strong aria-hidden="true">6.1.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="strings.html"><strong aria-hidden="true">6.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="booleans.html"><strong aria-hidden="true">6.3.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="4d-vectors.html"><strong aria-hidden="true">6.4.</strong> 4D vectors</a></li><li class="chapter-item expanded "><a href="4d-matrices.html"><strong aria-hidden="true">6.5.</strong> 4D matrices</a></li><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">6.6.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="objects.html"><strong aria-hidden="true">6.7.</strong> Objects</a></li><li class="chapter-item expanded "><a href="links.html"><strong aria-hidden="true">6.8.</strong> Links</a></li><li class="chapter-item expanded "><a href="closures.html"><strong aria-hidden="true">6.9.</strong> Closures</a></li><li class="chapter-item expanded "><a href="options.html"><strong aria-hidden="true">6.10.</strong> Options</a></li><li class="chapter-item expanded "><a href="results.html"><strong aria-hidden="true">6.11.</strong> Results</a></li><li class="chapter-item expanded "><a href="threads.html"><strong aria-hidden="true">6.12.</strong> Threads</a></li><li class="chapter-item expanded "><a href="secrets.html"><strong aria-hidden="true">6.13.</strong> Secrets</a></li></ol></li><li class="chapter-item expanded "><a href="if.html"><strong aria-hidden="true">7.</strong> If</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">8.</strong> Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="break.html"><strong aria-hidden="true">8.1.</strong> Break</a></li><li class="chapter-item expanded "><a href="continue.html"><strong aria-hidden="true">8.2.</strong> Continue</a></li><li class="chapter-item expanded "><a href="infer-range.html"><strong aria-hidden="true">8.3.</strong> Infer range</a></li><li class="chapter-item expanded "><a href="packed-loops.html"><strong aria-hidden="true">8.4.</strong> Packed loops</a></li></ol></li><li class="chapter-item expanded "><a href="current-objects.html"><strong aria-hidden="true">9.</strong> Current objects</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">10.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ad-hoc-types.html"><strong aria-hidden="true">10.1.</strong> Ad-hoc types</a></li><li class="chapter-item expanded "><a href="complain-when-wrong.html"><strong aria-hidden="true">10.2.</strong> Complain when wrong</a></li><li class="chapter-item expanded "><a href="in-types.html"><strong aria-hidden="true">10.3.</strong> In-types</a></li></ol></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">11.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="error-handling.html"><strong aria-hidden="true">12.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="copy-on-write.html"><strong aria-hidden="true">13.</strong> Copy-on-write</a></li><li class="chapter-item expanded "><a href="dynamic-modules.html"><strong aria-hidden="true">14.</strong> Dynamic modules</a></li><li class="chapter-item expanded "><a href="look-up-functions.html"><strong aria-hidden="true">15.</strong> Look up functions</a></li><li class="chapter-item expanded "><a href="optimize-performance.html"><strong aria-hidden="true">16.</strong> Optimize performance</a></li><li class="chapter-item expanded "><a href="interop-with-rust.html"><strong aria-hidden="true">17.</strong> Interop with Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lib-dyon.html"><strong aria-hidden="true">17.1.</strong> lib.dyon</a></li><li class="chapter-item expanded "><a href="mutability-interop.html"><strong aria-hidden="true">17.2.</strong> Mutability interop</a></li><li class="chapter-item expanded "><a href="lifetime-interop.html"><strong aria-hidden="true">17.3.</strong> Lifetime interop</a></li><li class="chapter-item expanded "><a href="manual-interface.html"><strong aria-hidden="true">17.4.</strong> Manual interface</a></li></ol></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">18.</strong> Standard Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="command-arguments.html"><strong aria-hidden="true">18.1.</strong> Command-Line Arguments</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Dyon Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Dyon 0.39 tutorial!</p>
<p>Dyon is a dynamically typed scripting language,
designed for game engines and interactive applications.
It was started in 2016 by Sven Nilsen.</p>
<p>This tutorial is written for people with little programming experience.</p>
<p>The language in this tutorial is made simple on purpose.
If you are experienced programmer, you might want to skip to the parts that interests you.</p>
<h3 id="dyon-is-different"><a class="header" href="#dyon-is-different">Dyon is different!</a></h3>
<p>If you have used another programming language before,
there are some things worth to keep in mind:</p>
<p>Dyon has a limited memory model because of the lack of a garbage collector.
The language is designed to work around this limitation.</p>
<p>The language takes ideas from Javascript, Go and Rust, but focuses on practical features for making games:</p>
<ul>
<li>Optional type system with ad-hoc types</li>
<li>Similar object model to Javascript, but without <code>null</code></li>
<li>Built-in support for 4D vectors, HTML hex colors</li>
<li>Go-like coroutines</li>
</ul>
<p>There are plenty of new ideas in Dyon:</p>
<ul>
<li>Lifetime check for function arguments</li>
<li>Use <code>return</code> as local variable</li>
<li>Mathematical loops</li>
<li>Current objects</li>
<li>Secrets</li>
<li>Grab expressions</li>
<li>Dynamic modules as a way of organizing code</li>
</ul>
<h3 id="how-this-tutorial-is-organized"><a class="header" href="#how-this-tutorial-is-organized">How this tutorial is organized</a></h3>
<p>At the bottom there is a &quot;Comments&quot; section.
This contains things you might have noticed and things you can try out on your own.</p>
<h3 id="source-code"><a class="header" href="#source-code">Source code</a></h3>
<p>You will find the source code for all examples under &quot;examples&quot; in the <a href="https://github.com/pistondevelopers/dyon-tutorial">git repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Before you can run Dyon programs, you need to do the following:</p>
<ol>
<li>Install <a href="https://www.rust-lang.org/en-US/">Rust</a>.</li>
<li>Open up the Terminal window</li>
<li>Type <code>cargo new --bin &lt;project name&gt;</code></li>
</ol>
<p>Open up &quot;Cargo.toml&quot; and add the following:</p>
<pre><code>[dependencies]
dyon = &quot;0.36.0&quot;
</code></pre>
<p>Open up &quot;src/main.rs&quot; and type:</p>
<pre><pre class="playground"><code class="language-rust">extern crate dyon;

use dyon::{error, run};

fn main() {
    error(run(&quot;src/main.dyon&quot;));
}</code></pre></pre>
<h3 id="hello-world-example"><a class="header" href="#hello-world-example">Hello World example</a></h3>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/hello_world">examples/hello_world</a></p>
<p>Put this in &quot;src/main.dyon&quot;:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println(&quot;Hello world!&quot;)
}</code></pre></pre>
<p>In the terminal window, go to the &quot;hello_world&quot; folder and type:</p>
<pre><code>$ cargo run
</code></pre>
<p>This should print out:</p>
<pre><code>Hello world!
</code></pre>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>You might have noticed:</p>
<ul>
<li>Dyon has no &quot;;&quot; at the end of lines</li>
<li>The &quot;fn&quot; keyword is used by both Rust and Dyon</li>
<li>The &quot;main&quot; function is called when running the program</li>
<li>Double quotes &quot;&quot; are used for text</li>
</ul>
<p>Some things you can try:</p>
<ol>
<li>Put your name inside the text!</li>
<li>Add a new line where you print out something else!</li>
<li>Change &quot;println&quot; to &quot;print&quot; and see what happens!</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-1"><a class="header" href="#comments-1">Comments</a></h1>
<p>A comment is text to explain how some code works.
Comments are ignored when running the program.</p>
<p>Dyon uses <code>//</code> for single-line and <code>/* */</code> for multi-line comments.</p>
<pre><pre class="playground"><code class="language-rust">/*

This text is inside a multi-line comment.
It is ignored when running the program.

*/

fn main() {
    // Can I ask you something?
    println(&quot;hello?&quot;)
}</code></pre></pre>
<p>A single-line comment ignores the rest of the line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println(&quot;hello&quot;) // Prints `hello`.
<span class="boring">}</span></code></pre></pre>
<p>A multi-line comment starts with <code>/*</code> and ends with <code>*/</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* testing, testing! */
println(&quot;hello&quot;)
<span class="boring">}</span></code></pre></pre>
<p>You can nest <code>/* */</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
    /*
    A comment inside a comment!
    */
*/
<span class="boring">}</span></code></pre></pre>
<h3 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h3>
<p>It is more common to use <code>//</code> than <code>/* */</code> for documenting the code.</p>
<p>End a comment with a dot to make it easier to see where the line is ending:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Alice opened the door
// by pressing a button.
<span class="boring">}</span></code></pre></pre>
<p>You can use <code>/* */</code> to ignore some code without removing it:</p>
<pre><pre class="playground"><code class="language-rust">/*
fn main() {
    println(&quot;one&quot;)
}
*/

fn main() {
    println(&quot;two&quot;)
}</code></pre></pre>
<p>One technique that helps making code more understandable:
Organize the code in paragraphs, like in a book.
Write a single-line comment for each paragraph.
Separate paragraphs with an empty line.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Print the numbers from 1 to 10.
    list := sift i 10 { i + 1 }
    println(list)

    // Print the numbers from 11 to 20.
    list := sift i [10, 20) { i + 1 }
    println(list)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>In Dyon, there are two ways to declare a function.</p>
<p>One way is to use <code>fn</code> to define a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(x) -&gt; {
    return x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>If a function does not return a value, you leave out <code>-&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn say_hi() {
    println(&quot;hi!&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>Another way is to use mathematical notation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>f(x) = x + 1
<span class="boring">}</span></code></pre></pre>
<p>All mathematically declared functions returns a value.</p>
<p>Pro tip: To declare constants, use mathematical notation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Speed of light.
c() = 299_792_458
<span class="boring">}</span></code></pre></pre>
<h3 id="fibonacci-example"><a class="header" href="#fibonacci-example">Fibonacci example</a></h3>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/fibonacci">examples/fibonacci</a></p>
<pre><pre class="playground"><code class="language-rust">fib(x) = if x &lt;= 0 { 0 }
         else if x == 1 { 1 }
         else { fib(x-1) + fib(x-2) }

fn main() {
    for i 20 { println(fib(i)) }
}</code></pre></pre>
<p>Do not worry if you do not understand the code above.
This is just to show how to declare a function and call it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<p>In Dyon, when a function changes an argument, you need to add <code>mut</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(mut x) {
    x = 3
}

fn main() {
    a := 2
    foo(mut a)
    println(a) // prints `3`
}</code></pre></pre>
<p>A function that calls a function that changes an argument, also need <code>mut</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(mut x) {
    x = 3
}

// Requires `mut x` because it calls `foo`.
fn bar(mut x) {
    foo(mut x)
}

fn main() {
    a := 2
    bar(mut a)
    println(a) // prints `3`
}</code></pre></pre>
<p>This helps programmers understand the code.</p>
<p>Mutability information is part of the function name.
You can declare multiple functions with different mutability patterns:</p>
<pre><pre class="playground"><code class="language-rust">// `name`
name(person: {}) = clone(person.name)

// `name(mut,_)`
fn name(mut person, name) {
    person.name = clone(name)
}

fn main() {
    character := {name: &quot;Homer Simpson&quot;}
    println(name(character)) // prints `Homer Simpson`
    name(mut character, &quot;Marge Simpson&quot;)
    println(name(character)) // prints `Marge Simpson`
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="named-arguments"><a class="header" href="#named-arguments">Named arguments</a></h1>
<p>In Dyon, you can call some functions in two ways:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>attack__player_enemy(mut player, enemy)
attack(player: mut player, enemy: enemy)
<span class="boring">}</span></code></pre></pre>
<p>The named arguments are part of the function name.</p>
<ul>
<li>Double underscores separates function name from arguments</li>
<li>Arguments are separated by a single underscore</li>
</ul>
<p>It is common to use named arguments when there are lots of parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return"><a class="header" href="#return">Return</a></h1>
<p>In Dyon, <code>return</code> can be used as a variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(mut a: f64) -&gt; {
    return = a + 2
    a += 2
}
<span class="boring">}</span></code></pre></pre>
<p>If you leave out <code>=</code>, the function will exit with the value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: f64) -&gt; {
    return a + 2
    println(&quot;hi&quot;) // never gets called.
}
<span class="boring">}</span></code></pre></pre>
<p>Functions without <code>-&gt;</code> can use <code>return</code> without a value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    return
}
<span class="boring">}</span></code></pre></pre>
<p>All functions that returns a value must use <code>return</code>.
You get an error if you forget it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: f64) -&gt; { a + 2 } // ERROR
<span class="boring">}</span></code></pre></pre>
<pre><code>--- ERROR ---
In `source/test.dyon`:

Type mismatch (#775):
Expected `any`, found `void`
1,1: fn foo(a: f64) -&gt; { a + 2 }
1,1: ^
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A block starts with <code>{</code> and ends with <code>}</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := {
    println(&quot;hi!&quot;)
    5
}
println(a) // prints `5`
<span class="boring">}</span></code></pre></pre>
<p>The last expression in a block becomes the result of block expression.</p>
<p>When declaring a variable inside a block, you might get an error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := {
    b := 5
    b // ERROR
}
<span class="boring">}</span></code></pre></pre>
<pre><code>--- ERROR ---
In `source/test.dyon`:

`b` does not live long enough
2,10:     a := {
2,10:          ^
3,1:         b := 5
4,1:         b // ERROR
5,1:     }
</code></pre>
<p>Dyon has no garbage collector, but uses a lifetime checker instead.
This is explained later in the chapter &quot;Lifetimes&quot;.</p>
<p>This means that &quot;b&quot; only lives for the scope of the block,
and you must use <code>clone</code> to fix it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := {
    b := 5
    clone(b) // OK
}
<span class="boring">}</span></code></pre></pre>
<p>When you do a math operation, Dyon knows it is safe:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := {
    b := 5
    b + 2 // OK
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 3 // Create a variable &quot;a&quot; with value `3`.
a = 4 // Change the value of variable &quot;a&quot; to `4`.
<span class="boring">}</span></code></pre></pre>
<p>A variable has a name, a type and a value.</p>
<ul>
<li>The operator <code>:=</code> creates a variable.</li>
<li>The operator <code>=</code> changes the value of a variable.</li>
</ul>
<p>When changing the value of a variable, the type must be the same:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 3
a = &quot;hi!&quot; // ERROR
<span class="boring">}</span></code></pre></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)

Expected assigning to text
3,5:     a = &quot;hi!&quot; // ERROR
3,5:     ^
</code></pre>
<h3 id="echo-example"><a class="header" href="#echo-example">Echo example</a></h3>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/echo">examples/echo</a></p>
<p>Create a new project and name it &quot;echo&quot;.</p>
<p>Put this in &quot;src/main.dyon&quot;:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print(&quot;Type something: &quot;)
    line := read_line()
    sleep(1)
    println(line)
}</code></pre></pre>
<p>This program prints out the text you gave it after 1 second.
The text is stored inside a variable &quot;line&quot;.</p>
<h3 id="comments-2"><a class="header" href="#comments-2">Comments</a></h3>
<p>You might have noticed:</p>
<ul>
<li><code>println</code> ends with a new line, while <code>print</code> stays at same line</li>
</ul>
<p>Some things you can try:</p>
<ol>
<li>Print out &quot;You said: (line)&quot;!</li>
<li>Change <code>sleep(1)</code> to wait 5 seconds!</li>
<li>Change the name of &quot;line&quot; to something else!</li>
<li>Put &quot;println(line)&quot; first and see what happens!</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<p>A number in Dyon is a variable that stores floats with 64 bit precision.
The type is <code>f64</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 1
b := .5
c := 2.5
d := -3
e := 1_000_000
f := 1e6
g := -7_034.52e-22
<span class="boring">}</span></code></pre></pre>
<p>You can add, subtract, multiply, divide, take the power and find the division reminder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 2
b := a + 3
c := a - 3
d := a * 3
e := a^3
f := a / 3
g := a % 3
<span class="boring">}</span></code></pre></pre>
<h3 id="relative-change"><a class="header" href="#relative-change">Relative change</a></h3>
<p>The following operators change the value relatively:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a += 1 // increase by 1
a -= 1 // declare by 1
a *= 2 // multiply by 2
a /= 2 // divide by 2
a %= 2 // find division reminder of 2
<span class="boring">}</span></code></pre></pre>
<h3 id="comments-3"><a class="header" href="#comments-3">Comments</a></h3>
<p>Some thing you might have noticed:</p>
<ul>
<li><code>f64</code> is used by both Rust and Dyon</li>
<li>&quot;One million&quot; can be written as <code>1_000_000</code> or <code>1e6</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>A string in Dyon is a variable that stores UTF-8 bytes.
This represent text.
The type is <code>str</code>.</p>
<p>Use double quotes to write a string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := &quot;hi!&quot;
<span class="boring">}</span></code></pre></pre>
<p>The <code>\</code> symbol escapes special characters:</p>
<ul>
<li><code>\n</code> - New line</li>
<li><code>\t</code> - Tab</li>
<li><code>\&quot;</code> - The <code>&quot;</code> character</li>
<li><code>\\</code> - The <code>\</code> character</li>
<li><code>\r</code> - Moves to beginning of line without creating a new line</li>
<li><code>\u005c</code> - Unicode character by 4 hexadecimal code</li>
</ul>
<p>The <code>+</code> operator joins two strings together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>name := &quot;Santa&quot;
title := &quot;hi &quot; + name
<span class="boring">}</span></code></pre></pre>
<p>The <code>str</code> function converts a value into a string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>age := 58
println(&quot;Bilbo is &quot; + str(age) + &quot; years old!&quot;)
<span class="boring">}</span></code></pre></pre>
<h3 id="some-useful-functions-for-strings"><a class="header" href="#some-useful-functions-for-strings">Some useful functions for strings</a></h3>
<ul>
<li><code>fn str(any) -&gt; str</code> - convert a variable to a string</li>
<li><code>fn read_line() -&gt; str</code> - read line from standard input</li>
<li><code>fn trim(str) -&gt; str</code> - trims away whitespace at both sides</li>
<li><code>fn trim_left(str) -&gt; str</code> - trims away whitespace at left side</li>
<li><code>fn trim_right(str) -&gt; str</code> - trims away whitespace at right side</li>
<li><code>fn json_string(str) -&gt; str</code> - creates a JSON string</li>
<li><code>fn str__color(vec4) -&gt; str</code> - HTML hex color string</li>
<li><code>fn chars(str) -&gt; [str]</code> - characters of a string</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booleans"><a class="header" href="#booleans">Booleans</a></h1>
<p>A boolean in Dyon is a variable that stores <code>true</code> or <code>false</code>.
This represents a choice with two options.
The type is <code>bool</code>.</p>
<h3 id="lazy-and-eager"><a class="header" href="#lazy-and-eager">Lazy and eager</a></h3>
<p>A lazy operator does not compute the right argument if the left argument gives the result.</p>
<p>An eager operator computes both arguments.</p>
<h3 id="logical-gates"><a class="header" href="#logical-gates">Logical gates</a></h3>
<p>A logical gate is an operation on two boolean values.</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A AND B</th><th>A OR B</th><th>A XOR B</th><th>A EXC B</th></tr></thead><tbody>
<tr><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr>
<tr><td>false</td><td>true</td><td>false</td><td>true</td><td>true</td><td>false</td></tr>
<tr><td>true</td><td>false</td><td>false</td><td>true</td><td>true</td><td>true</td></tr>
<tr><td>true</td><td>true</td><td>true</td><td>true</td><td>false</td><td>false</td></tr>
</tbody></table>
</div>
<p>There are 4 operators for AND:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a &amp;&amp; b // lazy
a and b // eager
a ∧ b // eager
a * b // eager
<span class="boring">}</span></code></pre></pre>
<p>There are 4 operators for OR:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a || b // lazy
a or b // eager
a ∨ b // eager
a + b // eager
<span class="boring">}</span></code></pre></pre>
<p>There is 1 operator for XOR:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a ^ b
<span class="boring">}</span></code></pre></pre>
<p>There is 1 operator for EXC:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a - b
<span class="boring">}</span></code></pre></pre>
<p>There are 2 operators for NOT:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>!a
¬a
<span class="boring">}</span></code></pre></pre>
<h3 id="why-more-than-one-way"><a class="header" href="#why-more-than-one-way">Why more than one way</a></h3>
<p>Boolean algebra is used with different notations:</p>
<ul>
<li>Programming applications</li>
<li>Logic</li>
<li>Non-invertible sets</li>
</ul>
<p>When programming applications, you use <code>&amp;&amp;</code>, <code>||</code> and <code>!</code>.</p>
<p>Logic use <code>∧</code>, <code>∨</code> and <code>¬</code>.</p>
<p>Non-invertible sets uses <code>*</code>, <code>+</code> and <code>-</code>.</p>
<p>In the future Dyon might get more features for Boolean algebra.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4d-vectors"><a class="header" href="#4d-vectors">4D vectors</a></h1>
<p>In Dyon, you can compute with 4D vectors:</p>
<pre><code>(x, y, z, w)
</code></pre>
<p>Many operations are built-in for working with 4D vectors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (1, 2, 3, 4)
b := (5, 6, 7, 8)
println(a + b) // prints `(6, 8, 10, 12)`
<span class="boring">}</span></code></pre></pre>
<p>The components <code>z</code> and <code>w</code> are set to 0 by default:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (1, 2)
<span class="boring">}</span></code></pre></pre>
<p>The <code>y</code> component can also be set to 0, but requires &quot;,&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (1,)
<span class="boring">}</span></code></pre></pre>
<h3 id="html-hex-colors"><a class="header" href="#html-hex-colors">HTML hex colors</a></h3>
<p>A HTML hex color is converted into a 4D vector:</p>
<pre><code>a := #ff0000 // red
b := #00ff00 // green
c := #0000ff // blue
d := #00000033 // semi-transparent black
</code></pre>
<h3 id="swizzle-components"><a class="header" href="#swizzle-components">Swizzle components</a></h3>
<p>To swizzle components, you can use this notation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (1, 2)
b := (yx a,)
<span class="boring">}</span></code></pre></pre>
<p>You can repeat a component up to 4 times:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (1, 2)
b := (yyyy a,)
println(b) // prints `(2, 2, 2, 2)`
<span class="boring">}</span></code></pre></pre>
<h3 id="calling-functions"><a class="header" href="#calling-functions">Calling functions</a></h3>
<p>When calling a function, you can unpack vector components:</p>
<pre><pre class="playground"><code class="language-rust">add(x, y) = x + y

fn main() {
    a := (1, 2)
    println(add(xy a)) // prints `3`
}</code></pre></pre>
<p>If a function takes named arguments, you can use this trick:</p>
<pre><pre class="playground"><code class="language-rust">add__x_y(x, y) = x + y

fn main() {
    a := (1, 2)
    println(add(x_y: xy a)) // prints `3`
}</code></pre></pre>
<h3 id="addition-and-multiplication"><a class="header" href="#addition-and-multiplication">Addition and multiplication</a></h3>
<p>Addition and multiplication is per component for two vectors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1, 2) + (3, 4) // `(4, 6)`
(1, 2) * (3, 4) // `(3, 8)`
<span class="boring">}</span></code></pre></pre>
<p>Scalar addition, multiplication and division is allowed on both sides
and is per component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1, 2) + 1 // `(2, 3, 1, 1)`
3 + (1, 2) // `(4, 5, 3, 3)`
(1, 2) * 2 // `(2, 4)`
2 * (1, 2) // `(2, 4)`
(1, 2) / 2 // `(0.5, 1)`
2 / (1, 2, 4, 8) // `(2, 1, 0.5, 0.25)`
<span class="boring">}</span></code></pre></pre>
<h3 id="dot-product"><a class="header" href="#dot-product">Dot product</a></h3>
<p>Dot product of two vectors can be written in two ways:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (1, 2)
b := (3, 4)
println(a *. b)
println(a · b)
<span class="boring">}</span></code></pre></pre>
<h3 id="cross-product"><a class="header" href="#cross-product">Cross product</a></h3>
<p>Cross product of two vectors can be written in two ways:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (1, 2)
b := (3, 4)
println(a x b)
println(a ⨯ b)
<span class="boring">}</span></code></pre></pre>
<h3 id="norm"><a class="header" href="#norm">Norm</a></h3>
<p>The norm of a vector, also called &quot;length&quot; or &quot;magnitude&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := (3, 4)
println(|a|)
<span class="boring">}</span></code></pre></pre>
<h3 id="un-loops"><a class="header" href="#un-loops">Un-loops</a></h3>
<p>The <code>vec4</code>, <code>vec3</code>, <code>vec2</code> are un-rolled and replaces the index with a number:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    a := vec4 i { i + 1 }
    println(a) // prints `(1, 2, 3, 4)`
}</code></pre></pre>
<p>You can check this by printing out a closure:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    a := \() = vec4 i { i + 1 }
    // prints `\() = ({ 0 + 1 }, { 1 + 1 }, { 2 + 1 }, { 3 + 1 })`
    println(a)
}</code></pre></pre>
<h3 id="other-functions-for-4d-vectors"><a class="header" href="#other-functions-for-4d-vectors">Other functions for 4D vectors:</a></h3>
<ul>
<li><code>fn x(vec4) -&gt; f64</code> - get x component</li>
<li><code>fn y(vec4) -&gt; f64</code> - get y component</li>
<li><code>fn z(vec4) -&gt; f64</code> - get z component</li>
<li><code>fn w(vec4) -&gt; f64</code> - get w component</li>
<li><code>fn s(vec4, f64) -&gt; f64</code> - get vector component by index</li>
<li><code>fn dir__angle(f64) -&gt; vec4</code> - rotation vector around Z axis</li>
</ul>
<h3 id="precision"><a class="header" href="#precision">Precision</a></h3>
<p>Whenever you do calculations with 4D vectors, you get float 32 bit precision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4d-vectors-1"><a class="header" href="#4d-vectors-1">4D vectors</a></h1>
<p>In Dyon, you can compute with 4D matrices:</p>
<pre><code>mat4 {
  m00, m01, m02, m03;
  m10, m11, m12, m13;
  m20, m21, m22, m23;
  m30, m31, m32, m33;
}
</code></pre>
<p>Many operations are built-in for working with 4D matrices:</p>
<pre><code>fn main() {
    a := mat4 {1,;}
    b := mat4 {1,;}
    // prints `mat4 {2,0,0,0; 0,2,0,0; 0,0,2,0; 0,0,0,2}`
    println(a + b)
}
</code></pre>
<p>4D vectors used as rows:</p>
<pre><code>mat4 {(1, 0, 0, 0); (0, 1, 0, 0); (0, 0, 1, 0); (0, 0, 0, 1)}
</code></pre>
<p>Omitted parentheses:</p>
<pre><code>mat4 {1,0,0,0; 0,1,0,0; 0,0,1,0; 0,0,0,1}
</code></pre>
<p>Omitted trailing zeroes:</p>
<pre><code>mat4 {1,; 0,1; 0,0,1; 0,0,0,1}
</code></pre>
<p>Fills out rows corresponding to identity matrix:</p>
<pre><code>mat4 {1,; 0,1; 0,0,1}
</code></pre>
<p>Identity matrix:</p>
<pre><code>mat4 {1,;}
</code></pre>
<h3 id="addition-and-multiplication-1"><a class="header" href="#addition-and-multiplication-1">Addition and multiplication</a></h3>
<p>Addition is per component for two matrices.</p>
<p>Multiplication is matrix multiplication.</p>
<pre><code>fn main() {
    a := mat4 {1,;}
    b := a + a
    // Prints `mat4 {2,0,0,0; 0,2,0,0; 0,0,2,0; 0,0,0,2}`.
    println(b)

    // Prints `mat4 {4,0,0,0; 0,4,0,0; 0,0,4,0; 0,0,0,4}`.
    c := b * b
    println(c)
}
</code></pre>
<p><code>+=</code>, <code>-=</code> and <code>*=</code>:</p>
<pre><code>fn main() {
    a := mat4 {1,;}
    a += a
    // Prints `mat4 {2,0,0,0; 0,2,0,0; 0,0,2,0; 0,0,0,2}`.
    println(a)

    // Prints `mat4 {4,0,0,0; 0,4,0,0; 0,0,4,0; 0,0,0,4}`.
    a *= a
    println(a)

    // Prints `mat4 {3,0,0,0; 0,3,0,0; 0,0,3,0; 0,0,0,3}`
    a -= mat4 {1,;}
    println(a)
}
</code></pre>
<p><code>+</code>, <code>-</code> and <code>*</code> with scalars and matrices is per component:</p>
<pre><code>fn main() {
    a := mat4 {1,2,3,4;2,3,4,1;3,4,1,2;4,1,2,3}
    println(2 * a)
    println(a * 2)
    println(2 + a)
    println(a + 2)
    println(2 - a)
    println(a - 2)
}
</code></pre>
<p>Transform 4D vector by multiplying a 4D matrix with a <code>vec4</code> that has a zero in the 4th component:</p>
<pre><code>fn main() {
    // Scale x-axis up 2 times.
    a := mat4 {2,;}
    println(a * (1, 1, 1))

    // Scale y-axis up 2 times.
    a := mat4 {1,; 0,2}
    println(a * (1, 1, 1))

    // Scale z-axis up 2 times.
    a := mat4 {1,; 0,1; 0,0,2}
    println(a * (1, 1, 1))
    // The same using `scale`.
    println(scale((1, 1, 2)) * (1, 1, 1))
}
</code></pre>
<p>Transform a point by multiplying a 4D matrix with a <code>vec4</code> that has a one in the 4th component:</p>
<pre><code>fn main() {
    pos := (1, 2, 3)
    // Put `1` in the 4th component to transform a point.
    println(mov((1, 2)) * (xyz pos, 1))
}
</code></pre>
<p>Get row vectors with <code>rx</code>, <code>ry</code>, <code>rz</code>, <code>rw</code>, <code>rv</code> and get column vectors with <code>cx</code>, <code>cy</code>, <code>cz</code>, <code>cw</code>, <code>cv</code>:</p>
<pre><code>fn main() {
    a := mat4 {
        1,2,3,4;
        5,6,7,8;
        9,10,11,12;
        13,14,15,16;
    }

    // Print row vectors.
    println(rx(a)) // Prints `(1, 2, 3, 4)`.
    println(ry(a)) // Prints `(5, 6, 7, 8)`.
    println(rz(a)) // Prints `(9, 10, 11, 12)`.
    println(rw(a)) // Prints `(13, 14, 15, 16)`.

    // Print row vectors using a loop.
    for i 4 {println(rv(a, i))}

    // Print column vectors.
    println(cx(a)) // Prints `(1, 5, 9, 13)`
    println(cy(a)) // Prints `(2, 6, 10, 14)`
    println(cz(a)) // Prints `(3, 7, 11, 15)`
    println(cw(a)) // Prints `(4, 8, 12, 16)`

    // Print column vectors using a loop.
    for i 4 {println(cv(a, i))}
}
</code></pre>
<h3 id="negation"><a class="header" href="#negation">Negation</a></h3>
<p>Negation is per component:</p>
<pre><code>a := mat4 {1,;}
// Prints `mat4 {-1,0,0,0; 0,-1,0,0; 0,0,-1,0; 0,0,0,-1}`
println(-a)
</code></pre>
<h3 id="other-functions-for-4d-vectors-1"><a class="header" href="#other-functions-for-4d-vectors-1">Other functions for 4D vectors:</a></h3>
<ul>
<li><code>fn det(m: mat4) -&gt; f64</code> determinant</li>
<li><code>fn inv(m: mat4) -&gt; mat4 </code> inverse</li>
<li><code>fn mov(v: vec4) -&gt; mat4</code> translation</li>
<li><code>fn scale(v: vec4) -&gt; mat4</code> scale</li>
<li><code>fn rot__axis_angle(axis: vec4, angle: f64) -&gt; mat4</code> axis-angle rotation</li>
<li><code>n ortho__pos_right_up_forward(pos: vec4, right: vec4, up: vec4, forward: vec4) -&gt; mat4</code> orthogonal view</li>
<li><code>fn proj__fov_near_far_ar(fov: f64, near: f64, far: f64, ar: f64) -&gt; mat4</code> projection view</li>
<li><code>fn mvp__model_view_projection(model: mat4, view: mat4, projection: mat4) -&gt; mat4</code> model-view-projection</li>
</ul>
<h3 id="precision-1"><a class="header" href="#precision-1">Precision</a></h3>
<p>Whenever you do calculations with 4D matrices, you get float 32 bit precision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>An array stores a list of values. The type is <code>[]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := [1, 2, 3]
<span class="boring">}</span></code></pre></pre>
<p>You can store values of different types in the same array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := [1, &quot;hi&quot;, [1, 2, 3]]
<span class="boring">}</span></code></pre></pre>
<p>To access an value inside an array, you use a number that start at <code>0</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := [1, 2, 3]
println(a[0]) // prints `1`
println(a[1]) // prints `2`
println(a[2]) // prints `3`
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-dimensional-arrays"><a class="header" href="#multi-dimensional-arrays">Multi-dimensional arrays</a></h3>
<p>An array can contain arrays.
This makes it possible to represent grids in 2D, 3D etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := [1, 2, 3] // 1D
println(a[0]) // prints `1`

b :=  [ // 2D
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
println(b[0][0]) // prints `1`

c :=  [ // 3D
          [[1, 2], [3, 4]],
          [[5, 6], [7, 8]],
      ]
println(a[0][0][0]) // prints `1`
<span class="boring">}</span></code></pre></pre>
<h3 id="memory"><a class="header" href="#memory">Memory</a></h3>
<p>Each item in an array takes 24 bytes (64 bit platforms):</p>
<ul>
<li>8 bytes for type information</li>
<li>16 bytes for item data</li>
</ul>
<p>This is optimized to store 4D vectors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>An object stores a list of values, organized as a dictionary. The type is <code>{}</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := {x: 1, y: &quot;hi&quot;}
<span class="boring">}</span></code></pre></pre>
<p>To change a value in an object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a.x = 2
<span class="boring">}</span></code></pre></pre>
<p>Alternative:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a[&quot;x&quot;] = 2
<span class="boring">}</span></code></pre></pre>
<p>The value must be of the same type.</p>
<p>If you want to change the type, use <code>:=</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a.x := &quot;hi!&quot;
<span class="boring">}</span></code></pre></pre>
<p>Insert new keys and values with <code>:=</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := {}
a.x := 1
a.y := 2
a.z := 3
<span class="boring">}</span></code></pre></pre>
<h3 id="some-useful-functions"><a class="header" href="#some-useful-functions">Some useful functions</a></h3>
<ul>
<li><code>fn has({}, str) -&gt; bool</code> - return <code>true</code> if object has key</li>
<li><code>fn keys({}) -&gt; [str]</code> - return keys of object</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links"><a class="header" href="#links">Links</a></h1>
<p>A link in Dyon is a variable that stores <code>bool</code>, <code>f64</code> and <code>str</code> efficiently.
It is called &quot;link&quot; because it is fast and easy to put together data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>name := &quot;John&quot;
a := link {&quot;Hi &quot;name&quot;!&quot;}
<span class="boring">}</span></code></pre></pre>
<p>The data inside a link can not be changed.
You can read the data using <code>head</code> and <code>tail</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := link { 1 2 3 }
b := head(a) // `some(1)`
c := tail(a) // `link { 2 3 }`
<span class="boring">}</span></code></pre></pre>
<p>When you put a link inside a link, it gets flattened:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := link { 1 2 3 }
// `link { &quot;start &quot;1 2 3&quot; end&quot; }`
b := link { &quot;start &quot;a&quot; end&quot; }
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-use-links"><a class="header" href="#when-to-use-links">When to use links</a></h3>
<p>Links are often used to:</p>
<ul>
<li>Generate lots of data and then convert to <code>str</code></li>
<li>Pre-process parts of a text template</li>
<li>Generate a web page</li>
<li>Code generation</li>
<li>Store lots of <code>f64</code>, <code>bool</code> or <code>str</code> in memory</li>
</ul>
<p>Because of the easy syntax for links, you can use Dyon as a template language.</p>
<h3 id="memory-1"><a class="header" href="#memory-1">Memory</a></h3>
<p>The memory of a link is divided into blocks of 1024 bytes (64 bit platforms).</p>
<p>A link takes only 3.2% extra memory than the ideal amount when blocks are filled.</p>
<p>To save memory with a link compared to an array, you need 42 items:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := link {
        0 1 2 3 4 5 6 7 8
        9 10 11 12 13 14 15 16
        17 18 19 20 21 22 23 24
        25 26 27 28 29 30 31 32
        33 34 35 36 37 38 39 40
        41 42
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="other-operators"><a class="header" href="#other-operators">Other operators</a></h3>
<p>You can use <code>+=</code> (back) and <code>-=</code> (front) to link together link blocks.
This is faster, but uses a little more memory.</p>
<p>You can not use <code>+</code> because it is too easy to waste memory by error.</p>
<h3 id="some-useful-functions-1"><a class="header" href="#some-useful-functions-1">Some useful functions</a></h3>
<ul>
<li><code>fn is_empty(link) -&gt; bool</code> - return <code>true</code> if link is empty</li>
<li><code>fn head(link) -&gt; opt[any]</code> - return first item in link</li>
<li><code>fn tail(link) -&gt; link</code> - return whole link except first item</li>
<li><code>fn tip(link) -&gt; opt[any]</code> - return last item in link</li>
<li><code>fn neck(link) -&gt; link</code> - return whole link except last item</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>A closure in Dyon is a variable that works similar to a mathematical function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := \(x) = x + 1
<span class="boring">}</span></code></pre></pre>
<p>You can print out a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// prints `\(x: any) = x + 1`
println(\(x) = x + 1)
<span class="boring">}</span></code></pre></pre>
<p>To call a closure, use the <code>\</code> character before the name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := \(x) = x + 1
println(\a(0)) // prints `1`
<span class="boring">}</span></code></pre></pre>
<h3 id="calling-closures-on-objects"><a class="header" href="#calling-closures-on-objects">Calling closures on objects</a></h3>
<p>When an object stores a closure, you can call it with named arguments:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    gollum := {say__msg: \(msg) = &quot;My precious &quot; + msg}
    // prints `my precious ring`
    println(\gollum.say(msg: &quot;ring&quot;))
}</code></pre></pre>
<h3 id="grab"><a class="header" href="#grab">Grab</a></h3>
<p>Use <code>grab</code> to compute a value and insert it into a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 2
b := \(x) = (grab a + 2) + x
// prints `\(x: any) = 4 + x`
println(b)
<span class="boring">}</span></code></pre></pre>
<p>When a closure is inside another closure, you can use <code>grab '2</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 2
b := \(x) = \(y) = (grab '2 a) + (grab x) + y
// prints `\(x: any) = \(y: any) = 2 + (grab x) + y`
println(b)
// prints `\(y: any) = 2 + 0 + y`
println(\b(0))
<span class="boring">}</span></code></pre></pre>
<p>You can use <code>grab 'N</code> where <code>N</code> is the level you want to compute from.</p>
<p>Pro tip: Pre-compute as much as possible with <code>grab</code> to improve performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>In Dyon, optional values are wrapped in <code>some(x)</code> or <code>none()</code>.
The type is <code>opt</code>, which defaults to <code>opt[any]</code>.</p>
<p>The <code>unwrap</code> function returns the value inside <code>some(x)</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    a := some(5)
    if a != none() {
        println(unwrap(a)) // prints `5`
    }
}</code></pre></pre>
<h3 id="note-to-programmers-accustomed-to-null"><a class="header" href="#note-to-programmers-accustomed-to-null">Note to programmers accustomed to <code>null</code></a></h3>
<p>Many languages uses <code>null</code> or <code>nil</code> to indicate an empty reference.
This leads to lots of maintenance problems, because it can appear anywhere.</p>
<p>Dyon uses <code>opt</code> whenever you would use <code>null</code> in another language.
This forces programmers to deal with it explicitly,
which reduces number of bugs in the program.</p>
<h3 id="some-useful-functions-2"><a class="header" href="#some-useful-functions-2">Some useful functions</a></h3>
<ul>
<li><code>fn some(any) -&gt; opt[any]</code></li>
<li><code>fn none() -&gt; opt[any]</code></li>
<li><code>fn unwrap(any) -&gt; any</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="results"><a class="header" href="#results">Results</a></h1>
<p>In Dyon, results are wrapped in <code>ok(x)</code> or <code>err(x)</code>.
The type is <code>res</code> which defaults to <code>res[any]</code>.
The error type is always <code>any</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    a := ok(5)
    if is_ok(a) {
        println(unwrap(a)) // prints `5`
    }
}</code></pre></pre>
<p>Result is used to handle errors explicitly.
Dyon has an operator <code>?</code> to make this easier.
You can read more about this in the chapter &quot;Error handling&quot;.</p>
<h3 id="some-useful-functions-3"><a class="header" href="#some-useful-functions-3">Some useful functions</a></h3>
<ul>
<li><code>fn unwrap(any) -&gt; any</code></li>
<li><code>fn unwrap_err(any) -&gt; any</code></li>
<li><code>fn is_ok(res[any]) -&gt; bool</code></li>
<li><code>fn is_err(res[any]) -&gt; bool</code></li>
<li><code>fn ok(any) -&gt; res[any]</code></li>
<li><code>fn err(any) -&gt; res[any]</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>In Dyon, a thread is created with the <code>go</code> keyword.
The type is <code>thr</code>, which defaults to <code>thr[any]</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn find_sum(n: f64) -&gt; f64 {
    return sum i n { i + 1 }
}

fn main() {
    a := go find_sum(1_000_000)
    println(unwrap(join(thread: a))) // prints `500000500000`
}</code></pre></pre>
<p>A thread runs in parallel.</p>
<h3 id="current-objects-are-not-passed-between-threads"><a class="header" href="#current-objects-are-not-passed-between-threads">Current objects are not passed between threads</a></h3>
<p>Dyon does a clone of variables that are passed to a <code>go</code> call.
The new thread starts with an empty stack.
This means that current objects are not shared between threads.</p>
<h3 id="there-can-only-be-one-reference-when-joining"><a class="header" href="#there-can-only-be-one-reference-when-joining">There can only be one reference when joining</a></h3>
<p>A thread must only have a single reference to it when joining.
For example, if you store threads in an an array, you need to use <code>pop</code>.</p>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/multi_threads">examples/multi_threads</a></p>
<pre><pre class="playground"><code class="language-rust">foo(i) = i + 40

fn main() {
    a := sift i 3 {go foo(i)}
    for i len(a) {
        println(unwrap(join(thread: pop(mut a))))
    }
}</code></pre></pre>
<h3 id="some-useful-functions-4"><a class="header" href="#some-useful-functions-4">Some useful functions</a></h3>
<ul>
<li><code>fn join__thread(thr[any]) -&gt; res[any]</code> - waits for the thread to finish, then returns the result</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secrets"><a class="header" href="#secrets">Secrets</a></h1>
<p>In Dyon, a secret is a hidden array of values associated with a <code>bool</code> or <code>f64</code>.
The type is <code>sec[bool]</code> or <code>sec[f64]</code>.</p>
<p>Secrets are used in combination with <code>any</code>/<code>all</code>/<code>max</code>/<code>min</code> loops.
This feature helps developers to write short and correct code.</p>
<p>For example, you can use secrets to find the first item in a list that
satisfies a condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [1, 2, 3]
a := any i { list[i] &gt; 2 }
if a {
    println(why(a)) // prints `[2]` because `list[2] == 3` and `3 &gt; 2`.
}
<span class="boring">}</span></code></pre></pre>
<p>It also works for lists inside lists:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [[1, 2], [3, 4]]
a := any i, j { list[i][j] &gt; 2 }
if a {
    println(why(a)) // prints `[1, 0]` because `list[1][0] == 3` and `3 &gt; 2`.
}
<span class="boring">}</span></code></pre></pre>
<p><code>max</code> and <code>min</code> loops uses the <code>where</code> keyword to unlock the secret:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [1, 2, 3, 4]
a := max i { list[i] }
println(where(a)) // prints `[3]` because `list[3]` is the greatest number.
<span class="boring">}</span></code></pre></pre>
<p>Secrets are used to solve problems that otherwise would be a bit tricky to code.
For example, the &quot;minimax&quot; algorithm which is
used to pick the best move when playing a zero-sum game:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>payoff := [[0, 1], [2, -1]]
a := min i {max j { payoff[i][j] }}
println(where(a)) // prints `[0, 1]` because that is the best move.
<span class="boring">}</span></code></pre></pre>
<p>In the beginning secrets might feel a bit &quot;backwards&quot;.
Instead of reducing a query into a <code>bool</code>, one can extract information from them!
Do not worry, because you will get used to it and you will like this feature
when programming complex logic.</p>
<p>Use <code>explain_why</code> to add a secret to a <code>bool</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := explain_why(true, &quot;hi!&quot;)
if a {
    println(why(a)) // prints `[&quot;hi!&quot;]`
}
<span class="boring">}</span></code></pre></pre>
<p>Use <code>explain_where</code> to add a secret to a <code>f64</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := explain_where(2.5, &quot;giant&quot;)
println(where(a)) // prints `[&quot;giant&quot;]`
<span class="boring">}</span></code></pre></pre>
<p>A secret propagates from the left argument of a binary operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := explain_where(2.5, &quot;giant&quot;)
is_tall := a &gt; 2.0
if is_tall {
    println(why(is_tall)) // prints `[&quot;giant&quot;]`
}
<span class="boring">}</span></code></pre></pre>
<p>When using a <code>min</code>, <code>max</code>, <code>any</code> or <code>all</code>, the indices are automatically added as secrets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [[1, 2], [3, 4]]
println(why(any i, j { list[i][j] &gt; 2 })) // prints `[1, 0]`
<span class="boring">}</span></code></pre></pre>
<h3 id="a-secret-must-have-meaning"><a class="header" href="#a-secret-must-have-meaning">A secret must have meaning</a></h3>
<p>The function <code>why</code> will only work if the value is <code>true</code>.
This prevents programs that do not make sense, such as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [1, 2, 3]
println(why(all i { list[i] &lt; 10 }))
<span class="boring">}</span></code></pre></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)
why

This does not make sense, perhaps an array is empty?
3,17:     println(why(all i { list[i] &lt; 10 }))
3,17:                 ^
</code></pre>
<p>Likewise, <code>where</code> will only work if the value is not <code>NaN</code> (0/0):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := []
println(where(min i { list[i] }))
<span class="boring">}</span></code></pre></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)

This does not make sense, perhaps an array is empty?
3,19:     println(where(min i { list[i] }))
3,19:                   ^
</code></pre>
<p>Remember to check for empty arrays!</p>
<h3 id="overhead"><a class="header" href="#overhead">Overhead</a></h3>
<p>Since Dyon supports 4D vectors, the size of the <code>Variable</code> enum is quite large.
This means better performance for 4D vectors but slower performance for <code>bool</code> and <code>f64</code>.
Dyon is designed for game development so this is a reasonable trade-off.
The overhead from executing extra instructions for secrets is not that large because of good cache locality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if"><a class="header" href="#if">If</a></h1>
<p>In Dyon, the <code>if</code> keyword runs a block if its condition is true:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 3 &lt; 4
if a {
    println(&quot;hi!&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>An <code>else</code> block runs when previous conditions are false:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 3 &gt; 4
if a {
    println(&quot;yes!&quot;)
} else {
    println(&quot;no...&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>An <code>else if</code> block runs when previous conditions are false and its condition is true:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 2
if a == 0 {
    println(&quot;=0&quot;)
} else if a == 1 {
    println(&quot;=1&quot;)
} else if a == 2 {
    println(&quot;=2&quot;)
} else {
    println(&quot;&gt;2&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>An <code>if</code> can be used as an expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 3
b := 3
c := 2 + if a == b { 1 } else { 0 }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>In Dyon there are 4 kinds of loops:</p>
<ul>
<li>Infinite loop</li>
<li>Traditional For loop</li>
<li>Mathematical loops</li>
<li>Link loop</li>
</ul>
<h3 id="infinite-loop"><a class="header" href="#infinite-loop">Infinite loop</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    println(&quot;hi!&quot;)
    sleep(1)
}
<span class="boring">}</span></code></pre></pre>
<p>An infinite loop runs runs forever, or until <code>break</code> is used inside it.</p>
<p>Tip: Use Ctrl+C to terminate an infinite loop in the Terminal window.</p>
<h3 id="traditional-for-loop"><a class="header" href="#traditional-for-loop">Traditional For loop</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i := 0; i &lt; 10; i += 1 {
    println(i)
}
<span class="boring">}</span></code></pre></pre>
<p>A traditional loop is similar to the loop in the programming language C.
It takes 3 expressions:</p>
<ul>
<li>Initialize, called first and once, e.g. <code>i := 0</code></li>
<li>Condition, checked for each turn, e.g. <code>i &lt; 10</code></li>
<li>Step, called after each turn, e.g. <code>i += 1</code></li>
</ul>
<h3 id="mathematical-loops"><a class="header" href="#mathematical-loops">Mathematical loops</a></h3>
<p>Dyon is famous for its mathematical loops:</p>
<ul>
<li><code>for</code> - do something for each turn</li>
<li><code>sift</code> - create an array out of values</li>
<li><code>min</code> - find the minimum value</li>
<li><code>max</code> - find the maximum value</li>
<li><code>∃</code>/<code>any</code> - check whether a condition is true for any value</li>
<li><code>∀</code>/<code>all</code> - check whether a condition is true for all values</li>
<li><code>∑</code>/<code>sum</code> - add values to get the sum</li>
<li><code>∏</code>/<code>prod</code> - multiply values to get the product</li>
<li><code>∑vec4</code>/<code>sum_vec4</code> - add 4D vectors to get the sum</li>
<li><code>∏vec4</code>/<code>prod_vec4</code> - multiply 4D vectors to get the product</li>
</ul>
<p>In mathematics, it is very common to loop over an index.
An index starts at 0, and increases with 1 for each turn.
All mathematical loops uses the same index notation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i 10 {
    println(i)
}
<span class="boring">}</span></code></pre></pre>
<p>This is equivalent to <code>for i := 0; i &lt; 10; i += 1</code>.</p>
<p>You can also specify the start and end value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i [0, 10) {
    println(i)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="link-loop"><a class="header" href="#link-loop">Link loop</a></h3>
<p>The link loop is similar to a link block, but for a repeated pattern.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [1, 2, 3]
println(link i {(i+1)&quot;: &quot;list[i]})
<span class="boring">}</span></code></pre></pre>
<p>All evaluated expressions are appended to the link.
Expressions that do not return a value are allowed inside a link loop.</p>
<p>Pro-tip: A link block inside a link loop gives you an all-or-nothing behavior.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    people := [{name: &quot;Homer&quot;}, {name: &quot;Bart&quot;}, {name: &quot;Marge&quot;}]
    kids := link i {link {
        &quot;name: &quot;
        name := people[i].name
        if name == &quot;Bart&quot; {continue} else {name}
        &quot;\n&quot;
    }}
    print(kids)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break"><a class="header" href="#break">Break</a></h1>
<p>The <code>break</code> keyword exits a loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a := 4
loop {
    a -= 1
    if a &lt; 0 { break }
}
<span class="boring">}</span></code></pre></pre>
<p>To exit an outer loop, use a label:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'outer: loop {
    loop {
        break 'outer
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In a mathematical loop, <code>break</code> skips the rest:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    list := [1, 2, 3]
    println(sum i {
        if i &gt; 1 { break } // skip `3`
        list[i]
    }) // prints `3`
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continue"><a class="header" href="#continue">Continue</a></h1>
<p>The <code>continue</code> keyword goes to the next turn.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    sleep(1)
    continue
    println(&quot;hi&quot;) // never called
}
<span class="boring">}</span></code></pre></pre>
<p>To go to the next turn of an outer loop, use a label:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'outer: loop {
    loop {
        continue 'outer
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In a mathematical loop, <code>continue</code> skips the current item:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    list := [1, 2, 3, 4]
    println(sum i {
        if i == 2 { continue } // skip `3`
        list[i]
    }) // prints `7`
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="infer-range"><a class="header" href="#infer-range">Infer range</a></h1>
<p>In Dyon, the range of a mathematical loop can be inferred from the loop body.</p>
<p>When iterating over a list, you can leave out start and end:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [1, 2, 3]

for i {
    println(list[i])
}
<span class="boring">}</span></code></pre></pre>
<p>This is equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [1, 2, 3]

for i len(list) {
    println(list[i])
}
<span class="boring">}</span></code></pre></pre>
<p>For nested loops, the indices must follow the same order as the loops:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list := [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
for i {
    for j {
        for k {
            println(list[i][j][k])
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packed-loops"><a class="header" href="#packed-loops">Packed loops</a></h1>
<p>In Dyon, you can pack mathematical loops together of the same kind:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i, j, k {
    println(list[i][j][k])
}
<span class="boring">}</span></code></pre></pre>
<p>This is equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i {
    for j {
        for k {
            println(list[i][j][k])
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can also specify start and end for each index:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    list := [1, 2, 3, 4]
    n := len(list)

    // For each pair.
    for i n, j [i + 1, n) {
        println(abs(list[i] - list[j]))
    }
}</code></pre></pre>
<p>Pro tip: If you find a packed loop hard to understand,
you can print out closure to see how it works:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    a := \() = {
        list := [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
        for i, j, k {
            println(list[i][j][k])
        }
    }
    println(a)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="current-objects"><a class="header" href="#current-objects">Current objects</a></h1>
<p>In Dyon, a current object is a variable that can be accessed by name.</p>
<p>To create a current object, use <code>~</code> when declaring a variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    ~ list := [1, 2, 3]
    print_list()
}

// Get the current object with name `list`.
fn print_list() ~ list {
    for i { println(list[i]) }
}</code></pre></pre>
<p>A new current object overrides the old one until it runs out of scope:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    ~ a := 2
    foo() // prints `2`
    {
        ~ a := 3
        foo() // prints `3`
    }
    foo() // prints `2`
}

fn foo() ~ a {
    println(a)
}</code></pre></pre>
<p>Current objects are useful to store things like settings or assets.</p>
<h3 id="note-to-programmers-accustomed-to-globals"><a class="header" href="#note-to-programmers-accustomed-to-globals">Note to programmers accustomed to globals</a></h3>
<p>Current objects replaces cases where you would use globals in another language.
Dyon does not support globals, because dynamic modules should not initialize memory upon loading.
A current object is like a global, except you must use it explicitly,
and it has a scope which can replace other current objects.
You might find it much easier to read code using current objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>In Dyon, there are two kinds of types:</p>
<ul>
<li>Runtime types, which only has one level</li>
<li>Static types, which can have more than one level</li>
</ul>
<h3 id="runtime-types"><a class="header" href="#runtime-types">Runtime types</a></h3>
<p>Dyon check the runtime type when using <code>=</code> to change a variable.
To get the runtime type, use the <code>typeof</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println(typeof(1.2)) // prints `number`
    println(typeof(true)) // prints `boolean`
    println(typeof(&quot;hi!&quot;)) // prints `string`
    println(typeof((1, 2))) // prints `vec4`
    println(typeof([1, 2, 3])) // prints `array`
    println(typeof({a: 2})) // prints `object`
    println(typeof(link { 1 2 3 })) // prints `link`
    println(typeof(some(2))) // prints `option`
    println(typeof(ok(2))) // prints `result`
    println(typeof(go foo())) // prints `thread`
    println(typeof(\(x) = x + 1)) // prints `closure`
    println(typeof(unwrap(load(&quot;src/main.dyon&quot;)))) // prints `rust_object`
}

fn foo() -&gt; { return ok(2) }</code></pre></pre>
<h3 id="static-types"><a class="header" href="#static-types">Static types</a></h3>
<p>Function arguments can have specify a static type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: f64) { ... }
<span class="boring">}</span></code></pre></pre>
<p>By default this is <code>any</code>.</p>
<p>Static types are used by the type checker to check for errors:</p>
<ul>
<li><code>any</code>, any type</li>
<li><code>f64</code>, number</li>
<li><code>bool</code>, boolean</li>
<li><code>str</code>, string</li>
<li><code>vec4</code>, 4D vector</li>
<li><code>[]</code>, array, defaults to <code>[any]</code></li>
<li><code>{}</code>, object</li>
<li><code>link</code>, link</li>
<li><code>opt</code>, defaults to <code>opt[any]</code></li>
<li><code>res</code>, defaults to <code>res[any]</code></li>
<li><code>thr</code>, defaults to <code>thr[any]</code></li>
<li>Closure type, e.g. <code>\(any, ..) -&gt; any</code></li>
<li>Ad-hoc type, e.g. <code>Foo</code>, defaults to <code>Foo {}</code></li>
</ul>
<p>There is no static type for Rust objects. Use an ad-hoc type, e.g. <code>Foo any</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ad-hoc-types"><a class="header" href="#ad-hoc-types">Ad-hoc types</a></h1>
<p>In Dyon, an ad-hoc type is a type that you just give a name.
It is not declared anywhere, but used directly when writing the functions.
Dyon treats ad-hoc types as distinct from each other.</p>
<pre><pre class="playground"><code class="language-rust">fn new_person(first_name: str, last_name: str) -&gt; Person {
    return {
        first_name: clone(first_name),
        last_name: clone(last_name)
    }
}

fn say_hello(person: Person) {
    println(&quot;Hi &quot; + person.first_name + &quot;!&quot;)
}

fn main() {
    homer := new_person(&quot;Homer&quot;, &quot;Simpson&quot;)
    say_hello(homer) // prints `Hi Homer!`
}</code></pre></pre>
<p>You can use any name that is not used by other Dyon types.
It is common to use CamelCase.</p>
<p><code>Person</code> is the same as <code>Person {}</code>, where <code>{}</code> is the inner type.</p>
<p>The inner type goes with the ad-hoc type and vice versa:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello(person: Person) {
    println(&quot;Hi &quot; + person.first_name + &quot;!&quot;)
}

fn main() {
    say_hello({first_name: &quot;Homer&quot;}) // prints `Hi Homer!`
}</code></pre></pre>
<h3 id="addition-and-multiplication-2"><a class="header" href="#addition-and-multiplication-2">Addition and multiplication</a></h3>
<p>Two ad-hoc types can be added if the inner type allows addition.</p>
<p>Dyon complains if you try to add an ad-hoc type with an inner type.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert number to `km`
fn km(v: f64) -&gt; km f64 { return v }

km(3) + km(4) // OK
km(3) + 4 // ERROR
<span class="boring">}</span></code></pre></pre>
<p>Multiplication is not allowed, because this often changes physical units.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complain-when-wrong"><a class="header" href="#complain-when-wrong">Complain when wrong</a></h1>
<p>In Dyon, the type checker only complains when it knows something is wrong.</p>
<p>When you do not specify the type of an argument, it defaults to <code>any</code>:</p>
<pre><pre class="playground"><code class="language-rust">foo(x) = x + 1

fn main() {
    println(foo(false))
}</code></pre></pre>
<p>In the program above, the type checker does not know that something is wrong.</p>
<p>You get a runtime error:</p>
<pre><code>--- ERROR ---
main (source/test.dyon)
foo (source/test.dyon)

Invalid type for binary operator `&quot;+&quot;`, expected numbers, vec4s, bools or strings
1,10: foo(x) = x + 1
1,10:          ^
</code></pre>
<p>To get a type error, add the type to the argument:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo(x: f64) = x + 1
<span class="boring">}</span></code></pre></pre>
<p>Now the type checker complains, because it knows that <code>false</code> is not <code>f64</code>:</p>
<pre><code>--- ERROR ---
In `source/test.dyon`:

Type mismatch (#100):
Expected `f64`, found `bool`
4,17:     println(foo(false))
4,17:                 ^
</code></pre>
<h3 id="static-types-are-not-guaranteed"><a class="header" href="#static-types-are-not-guaranteed">Static types are not guaranteed</a></h3>
<p>The type of an argument is not guaranteed to be the given static type.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">foo(x: f64) = x + 1

forget_type(x: any) = clone(x)

fn main() {
    println(foo(forget_type(false))) // ERROR
}</code></pre></pre>
<p>This gives you a runtime error, because the type checker is not that smart.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-types"><a class="header" href="#in-types">In-types</a></h1>
<p>In Dyon, an in-type receives input data from a function.</p>
<p>The <code>in</code> keyword creates a receiver channel:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x := in log
<span class="boring">}</span></code></pre></pre>
<p>Next time you call <code>log</code>, the input data is sent to <code>x</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn log(a: f64) {}

fn main() {
    x := in log
    log(1)
    println(next(x)) // Prints `some([1])`
}</code></pre></pre>
<h3 id="calling-functions-1"><a class="header" href="#calling-functions-1">Calling functions</a></h3>
<p>The type is <code>in[[]]</code> since arguments are stored in array:</p>
<pre><pre class="playground"><code class="language-rust">fn log(a: f64) {}

fn foo(x: in[[f64]]) {println(next(x))}

fn main() {
    x := in log
    log(1)
    foo(x)
}</code></pre></pre>
<h3 id="working-with-threads"><a class="header" href="#working-with-threads">Working With Threads</a></h3>
<p>In-types works across threads:</p>
<pre><pre class="playground"><code class="language-rust">fn log(a: f64) {}

fn finish() {}

fn bar(id: f64, n: f64) -&gt; bool {
    for i n {
        log((id + 1) * 1000 + i)
        sleep(0.1)
    }
    finish()
    return true
}

fn main() {
    log := in log
    finish := in finish
    n := 10
    for i n {_ := go bar(i, 2)}
    loop {
        for msg in log {println(msg[0])}
        if n == 0 {break}
        for done in finish {n -= 1}
    }
}</code></pre></pre>
<p>Notice that <code>n == 0</code> is checked after emptying the log for messages.</p>
<h3 id="other-functions-for-in-types"><a class="header" href="#other-functions-for-in-types">Other functions for in-types</a></h3>
<ul>
<li><code>fn next(channel: in) -&gt; opt[any]</code> - Blocks thread until message is received from channel.</li>
<li><code>fn try_next(channel: in) -&gt; opt[any]</code> - Checks for message on channel.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>In Dyon, a lifetime tells whether an argument outlives another argument.</p>
<h3 id="lifetimes-are-rare"><a class="header" href="#lifetimes-are-rare">Lifetimes are rare</a></h3>
<p>In normal programming there is little need to worry about lifetimes.</p>
<p>For example, use <code>clone</code> when putting a variable inside another:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn put(a, mut b) {
    b[0] = clone(a)
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn put(a: 'b, mut b) {
    b[0] = a
}
<span class="boring">}</span></code></pre></pre>
<p>It is useful to know how lifetimes work, but you rarely need them in practice.</p>
<h3 id="lifetimes-replaces-garbage-collector"><a class="header" href="#lifetimes-replaces-garbage-collector">Lifetimes replaces garbage collector</a></h3>
<p>Some languages can have a pointer to a variable that does not exist.
When this happens, it is called &quot;dangling pointer&quot;.
This can lead to unpredictable behavior and system crashes.
Languages that allow dangling pointer are unsafe,
and the programmer must be extra careful.</p>
<p>Many languages use a garbage collector to avoid dangling pointers.
Instead of removing the variable that the pointer points to,
it keeps it around in memory until all its pointers are gone.</p>
<p>Dyon uses static lifetime checks to ensure that dangling pointers are impossible.
This removes the need for a garbage collector.</p>
<h3 id="lifetimes-tell-the-order-of-declaration"><a class="header" href="#lifetimes-tell-the-order-of-declaration">Lifetimes tell the order of declaration</a></h3>
<p>A lifetime tells whether an argument outlives another argument:</p>
<pre><pre class="playground"><code class="language-rust">// `a` outlives `b`
fn put(a: 'b, mut b) {
    b[0] = a
}

fn main() {
    a := [2, 3]     // - lifetime of `a`
                    // |
    b := [[]]       // |  - lifetime of `b`
                    // |  |
    put(a, mut b)   // |  |
}</code></pre></pre>
<p>The variable &quot;a&quot; outlives &quot;b&quot; because it is declared before &quot;b&quot;.</p>
<p>The same program can be written like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    a := [2, 3]
    b := [[]]
    b[0] = a
}</code></pre></pre>
<p>Here, the order of the declared variables is known.</p>
<h3 id="the-return-lifetime"><a class="header" href="#the-return-lifetime">The <code>return</code> lifetime</a></h3>
<p>The <code>return</code> lifetime is the lifetime of the <code>return</code> variable.
This outlives the default lifetime of arguments (no lifetime).</p>
<p>If you return one of the argument, you must use <code>'return</code> or <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// With `'return` lifetime.
id(x: 'return) = x

// With `clone`.
id(x) = clone(x)
<span class="boring">}</span></code></pre></pre>
<h3 id="the-lifetime-checker-does-not-understand-types"><a class="header" href="#the-lifetime-checker-does-not-understand-types">The lifetime checker does not understand types</a></h3>
<p>In Dyon, the static type is not guaranteed at runtime,
therefore <code>bool</code>, <code>f64</code> and <code>str</code> follows same rules as <code>[]</code> or <code>{}</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: f64) -&gt; {
    return a // ERROR
}
<span class="boring">}</span></code></pre></pre>
<pre><code>--- ERROR ---
In `source/test.dyon`:

Requires `a: 'return`
2,12:     return a // ERROR
2,12:            ^
</code></pre>
<h3 id="lifetimes-are-about-references"><a class="header" href="#lifetimes-are-about-references">Lifetimes are about references</a></h3>
<p>A lifetime is about the references stored inside a variable.
All references outlive variables they are stored in.
Variables can not store references to themselves,
because it can not outlive itself.</p>
<p>In order to put a reference inside a variable, the lifetime checker
must know that the reference outlives the variable.</p>
<p>Because of the lifetime checker, all memory in Dyon is an acyclic graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>In Dyon, error handling uses the <code>?</code> operator to propagate errors.</p>
<pre><pre class="playground"><code class="language-rust">fn try_divide(a: f64, b: f64) -&gt; res[f64] {
    return if b == 0 { err(&quot;Division by zero&quot;) }
           else { ok(a / b) }
}

fn foo(b: f64) -&gt; res {
    a := try_divide(5, b)?
    return ok(a + 2)
}

fn main() {
    println(foo(2)) // prints `ok(4.5)`
    println(foo(0)) // prints `err(&quot;Division by zero&quot;)`
}</code></pre></pre>
<p>When using <code>unwrap</code>, an error is reported with a trace of all <code>?</code> operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println(unwrap(foo(0)))
<span class="boring">}</span></code></pre></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)
unwrap

Division by zero
In function `foo` (source/test.dyon)
7,10:     a := try_divide(5, b)?
7,10:          ^

15,20:     println(unwrap(foo(0)))
15,20:                    ^
</code></pre>
<p>An <code>opt</code> is converted into <code>res</code> when using <code>?</code>,
with the error &quot;Expected <code>some(_)</code>, found `none()&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-on-write"><a class="header" href="#copy-on-write">Copy-on-write</a></h1>
<p>In Dyon, arrays and objects uses atomic reference counting (Arc).</p>
<p>Whenever there are two non-stack references to the same array,
it will create a copy when changing the array:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // `[1, 2]` is inside an array,
    // and is therefore not stored in stack memory.
    a := [[1, 2]]
    // Create another reference to `[1, 2]`
    b := [a[0]]
    b[0][0] = 3
    println(b[0][0])
    // The old `[1, 2]` array remains unchanged.
    println(a[0][0])
}</code></pre></pre>
<p>This means that methods, the building-block of OOP patterns, are impossible to use in Dyon:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(mut a) {
    a[0] = 3
}

fn main() {
    // `[1, 2]` is inside an array,
    // and is therefore not stored in stack memory.
    a := [[1, 2]]
    // When we pass it as argument,
    // the reference counter is increased.
    foo(mut a[0])
    // The value remains unchanged,
    // because `foo` changed a copy.
    println(a[0][0]) // prints `1`
}</code></pre></pre>
<p>To modify variables inside other variables, it must be declared on the stack:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(mut a) {
    a[0] = 3
}

fn main() {
    // `[1, 2]` is put on the stack.
    list := [1, 2]
    // Putting a stack reference to `list` inside `a`
    a := [list]
    // When we pass it as argument,
    // the stack reference is passed.
    foo(mut a[0])
    // The value is changed.
    println(a[0][0]) // prints `3`
}</code></pre></pre>
<h3 id="data-oriented-design"><a class="header" href="#data-oriented-design">Data oriented design</a></h3>
<p>When writing programs in Dyon, you need to avoid copy-on-write.
The easiest way to do this is to organize application structure in flat arrays.</p>
<ul>
<li>Do not worry about having lots of arrays</li>
<li>Use current objects to pass arrays around</li>
<li>Batch changes to arrays together by iterating over them</li>
</ul>
<p>Optimize the data structure for the algorithms that process it.
When the algorithm changes, the data structure changes too!</p>
<h3 id="dyon-is-a-scripting-language"><a class="header" href="#dyon-is-a-scripting-language">Dyon is a scripting language</a></h3>
<p>If you need OOP patterns, then there is only one solution: Use another language, for example Rust.
Dyon is designed for scripting, as in solving problems fast.
It is not designed for building abstractions, or proving things through the type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-modules"><a class="header" href="#dynamic-modules">Dynamic modules</a></h1>
<p>In Dyon, you organize code by using dynamic modules.
It is common to write a loader script that loads modules and imports them to
other modules.</p>
<h3 id="dynmod-example"><a class="header" href="#dynmod-example">Dynmod example</a></h3>
<p>Source: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/dynmod">examples/dynmod</a></p>
<p>main.dyon:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    math := unwrap(load(&quot;src/math.dyon&quot;))
    game := unwrap(load(source: &quot;src/game.dyon&quot;, imports: [math]))
    call(game, &quot;main&quot;, [])
}</code></pre></pre>
<p>math.dyon:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>add(a: f64, b: f64) = a + b
<span class="boring">}</span></code></pre></pre>
<p>game.dyon:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    a := 2
    b := 3
    println(add(a, b)) // prints `5`
}</code></pre></pre>
<h3 id="calling-functions-in-dynamic-modules"><a class="header" href="#calling-functions-in-dynamic-modules">Calling functions in dynamic modules</a></h3>
<p>Dyon peforms a runtime lifetime check of arguments for these functions:</p>
<ul>
<li><code>fn call(module, name, args)</code> - returns no value</li>
<li><code>fn call_ret(module, name, args)</code> - returns value</li>
</ul>
<h3 id="why-dynamic-modules"><a class="header" href="#why-dynamic-modules">Why dynamic modules?</a></h3>
<p>Module loading is often an important part of a program:</p>
<ul>
<li>Download updates</li>
<li>Refresh game logic for interactive programming</li>
<li>Swap between backends</li>
</ul>
<p>For example, the same Dyon game can run on game engines that supports multiple backend APIs for rendering.
In other languages you might write generic code to make it reusable across APIs.
Dyon solves this by making all code reusable across APIs, as long as the
dependencies implement the same set of functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="look-up-functions"><a class="header" href="#look-up-functions">Look up functions</a></h1>
<p>In Dyon, you get all available functions with <code>functions</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println(functions())
}</code></pre></pre>
<p>You can write a program that looks up the information about a function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fs := functions()
    has_foo := any i { fs[i].name == &quot;foo&quot; }
    if has_foo {
        why := why(has_foo)
        println(fs[why[0]])
    }
}

fn foo() {}</code></pre></pre>
<pre><code>{returns: &quot;void&quot;, type: &quot;loaded&quot;, arguments: [], name: &quot;foo&quot;}
</code></pre>
<p>Because Dyon uses dynamic modules, <code>functions</code> is the only standard way
of obtaining this information. This can only be known in the loaded module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimize-performance"><a class="header" href="#optimize-performance">Optimize performance</a></h1>
<p>To optimize the performance of Dyon programs, compile with <code>cargo build --release</code>.</p>
<p>You can also get further optimization by disabling the default <code>debug_resolve</code> feature.
This compares location of variables on the stack with the static location.
It is not needed for running programs, but used to detect bugs in Dyon.</p>
<p>To disable <code>debug_resolve</code>, change the &quot;Cargo.toml&quot;:</p>
<pre><code>[dependencies.dyon]
version = &quot;0.8.0&quot;
features = []
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interop-with-rust"><a class="header" href="#interop-with-rust">Interop with Rust</a></h1>
<p>Dyon is designed to work with Rust, but uses different types.</p>
<p>Rust uses static types only, which usually takes up less memory and runs faster.
When you need to high performance, it is recommended to use Rust.</p>
<h3 id="functions-example"><a class="header" href="#functions-example">Functions example</a></h3>
<p>Source: <a href="https://github.com/PistonDevelopers/dyon/blob/master/examples/functions.rs">dyon/examples/functions.rs</a></p>
<p>The <code>dyon_fn!</code> macro lets you write a Rust function that maps to Dyon types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate dyon;

dyon_fn!{fn say_hello() {
    println!(&quot;hi!&quot;);
}}
<span class="boring">}</span></code></pre></pre>
<p>Add the function to a module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module.add(Arc::new(&quot;say_hello&quot;.into()), say_hello, Dfn {
      lts: vec![],
      tys: vec![],
      ret: Type::Void
  });
<span class="boring">}</span></code></pre></pre>
<p>The <code>dyon_obj!</code> macro lets to map new Rust structs to Dyon objects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person {
    pub first_name: String,
    pub last_name: String,
    pub age: u32,
}

dyon_obj!{Person { first_name, last_name, age }}
<span class="boring">}</span></code></pre></pre>
<p>All fields must implement <code>embed::PopVariable</code> and <code>embed::PushVariable</code>.</p>
<h3 id="the-dfn-struct"><a class="header" href="#the-dfn-struct">The <code>Dfn</code> struct</a></h3>
<p>The <code>Dfn</code> struct describes the type information of the function signature:</p>
<ul>
<li><code>lts</code> - lifetimes, e.g. <code>Lt::Default</code></li>
<li><code>tys</code> - types, e.g. <code>Type::F64</code></li>
<li><code>ret</code> - return type, e.g. <code>Type::Bool</code></li>
</ul>
<p>This is used by the lifetime and type checker when loading modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libdyon"><a class="header" href="#libdyon">lib.dyon</a></h1>
<p>When designing Dyon libraries written in Rust, it is common to include
a &quot;lib.dyon&quot; file in the &quot;src&quot; folder.
This file lists all external functions as they would appear in Dyon code.</p>
<p>Two examples from the Dyon library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns an array of derived information for the truth value of `var`.
/// This can be used with the value of `∃`/`any` and `∀`/`all` loops.
fn why(var: bool) -&gt; [any] { ... }

/// Returns an array of derived information for the value of `var`.
/// This can be used with the value of `min` and `max` loops.
fn where(var: f64) -&gt; [any] { ... }
<span class="boring">}</span></code></pre></pre>
<p>Comments should start with <code>///</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability-interop"><a class="header" href="#mutability-interop">Mutability interop</a></h1>
<p>Mutability information is part of the function name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(mut a: f64, b: f64) { ... }
<span class="boring">}</span></code></pre></pre>
<p>The name of this function is <code>foo(mut,_)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module.add(Arc::new(&quot;foo(mut,_)&quot;.into()), foo, Dfn {
      lts: vec![Lt::Default; 2],
      tys: vec![Type::F64; 2],
      ret: Type::Void
  });
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetime-interop"><a class="header" href="#lifetime-interop">Lifetime interop</a></h1>
<p>The <code>Lt</code> enum describes the lifetime of an argument.</p>
<p>The most common lifetime is <code>Lt::Default</code> (no lifetime).</p>
<p>If you have a function like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(mut a: [{}], b: 'a {}) { ... }
<span class="boring">}</span></code></pre></pre>
<p>Then the <code>Dfn</code> struct looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Dfn {
    lts: [Lt::Default, Lt::Arg(0)],
    tys: [Type::Array(Box::new(Type::Object)), Type::Object],
    ret: Type::Void
}
<span class="boring">}</span></code></pre></pre>
<p><code>Lt::Arg(0)</code> means the argument outlives the first argument.</p>
<p>Lifetimes must not be cyclic.
For example, this is not valid Dyon code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: 'b, b: 'a) { ... }
<span class="boring">}</span></code></pre></pre>
<p><code>Lt::Return</code> means the arugment outlives the return value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(a: 'return) -&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-interface"><a class="header" href="#manual-interface">Manual interface</a></h1>
<p>A manual interface gives more control over the interface between Rust and Dyon.
This is the only way to write external functions that mutate arguments.</p>
<p>The signature of an external function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn(rt: &amp;mut Runtime) -&gt; Result&lt;(), String&gt;
<span class="boring">}</span></code></pre></pre>
<p>These functions are useful when pushing and popping variables:</p>
<ul>
<li><code>Runtime::pop</code> - convert from stack</li>
<li><code>Runtime::pop_vec4</code> - convert 4D vector from stack</li>
<li><code>Runtime::pop_mat4</code> - convert 4D matrix from stack</li>
<li><code>Runtime::var</code> - convert from variable</li>
<li><code>Runtime::var_vec4</code> - convert 4D vector from variable</li>
<li><code>Runtime::push</code> - convert to variable on stack</li>
<li><code>Runtime::push_vec4</code> - convert to 4D vector on stack</li>
<li><code>Runtime::push_mat4</code> - convert to 4D matrix on stack</li>
<li><code>Runtime::resolve</code> - resolve a variable reference</li>
</ul>
<h3 id="getting-arguments-of-function"><a class="header" href="#getting-arguments-of-function">Getting arguments of function</a></h3>
<p>Since the Dyon runtime uses a stack, you must pop the argument in reverse order.
Before you use an argument, you must use <code>Runtime::resolve</code> in case
it is a reference to a variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let draw_list = rt.stack.pop().expect(&quot;There is no value on the stack&quot;);
let arr = rt.resolve(&amp;draw_list);
<span class="boring">}</span></code></pre></pre>
<p><code>Runtime::pop</code>, <code>Runtime::pop_var</code>, <code>Runtime::pop_vec4</code>, <code>Runtime::pop_mat4</code>, <code>Runtime::var</code>, <code>Runtime::var_vec4</code> and <code>Runtime::var_mat4</code>
resolves the variable for you.</p>
<h3 id="mutate-argument"><a class="header" href="#mutate-argument">Mutate argument</a></h3>
<p>To mutate an argument, you need to obtain a mutable reference to the
resolved variable on the stack:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = rt.stack.pop().expect(TINVOTS);

if let Variable::Ref(ind) = v {
    let ok = if let Variable::Array(ref mut arr) = rt.stack[ind] {
        Arc::make_mut(arr)...;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="return-value"><a class="header" href="#return-value">Return value</a></h3>
<p>After popping argument and computing a value, push the result on the stack.
Do not push more than one value, since Dyon only supports a single return value.</p>
<h3 id="reading-from-a-dyon-variable"><a class="header" href="#reading-from-a-dyon-variable">Reading from a Dyon variable</a></h3>
<p>The <code>Runtime::var</code> function converts a value inside a variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let radius: f64 = rt.var(&amp;it[2])?;
<span class="boring">}</span></code></pre></pre>
<h3 id="4d-vectors-2"><a class="header" href="#4d-vectors-2">4D vectors</a></h3>
<p>The <code>Runtime::var_vec4</code> function converts to a <code>vec4</code> convertible type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let color: [f32; 4] = rt.var_vec4(&amp;it[1])?;
<span class="boring">}</span></code></pre></pre>
<h3 id="4d-matrices"><a class="header" href="#4d-matrices">4D matrices</a></h3>
<p>The <code>Runtime::var_mat4</code> function converts to a <code>mat4</code> convertiable type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mat: [[f32; 4]; 4] = rt.var_mat4(&amp;it[1])?;
<span class="boring">}</span></code></pre></pre>
<h3 id="piston-current"><a class="header" href="#piston-current">Piston-Current</a></h3>
<p>Dyon keeps no track of variables in the Rust environment.
You can use the <a href="https://github.com/pistondevelopers/current">Piston-Current</a> crate to read from or change such variables by type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render(rt: &amp;mut Runtime) -&gt; Result&lt;(), String&gt; {
    rt.push(unsafe { Current::&lt;Option&lt;Event&gt;&gt;::new()
        .as_ref().expect(NO_EVENT).render_args().is_some() });
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>Dyon organizes functions in 3 ways:</p>
<ol>
<li>Dyon modules (also called &quot;loaded functions&quot;)</li>
<li>Rust interop (also called &quot;external functions&quot;)</li>
<li>Standard Library (also called &quot;intrinsics&quot;)</li>
</ol>
<ol>
<li>and 2) are explained in previous chapters.</li>
</ol>
<p>This chapter is about the third point 3) Standard Library.</p>
<p>This is what the Standard Library contains:</p>
<ul>
<li>Functions for loading modules and calling functions</li>
<li>Functions for using Dyon's built-in types</li>
<li>Functions for loading and saving data</li>
<li>Functions for meta-parsing</li>
</ul>
<p>The standard library of Dyon is small compared to e.g. Rust (less than 150 functions).
If you want to know the details of how it works, you can read the source code <a href="https://github.com/PistonDevelopers/dyon/tree/master/src/dyon_std">here</a>.</p>
<p>Some functions are in the standard library because they use
special knowledge that is not available in external functions.</p>
<p>This chapter shows some things you can do with the Standard Library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command-line arguments</a></h1>
<p>Dyon has a function to return an array of command-line arguments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_args_list {
    println(args_os())
}
<span class="boring">}</span></code></pre></pre>
<p>The first item is the path of the executable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
