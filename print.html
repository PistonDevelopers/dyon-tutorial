<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Dyon Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./getting-started.html"><strong>2.</strong> Getting started</a></li><li><a href="./comments.html"><strong>3.</strong> Comments</a></li><li><a href="./functions.html"><strong>4.</strong> Functions</a></li><li><ul class="section"><li><a href="./mutability.html"><strong>4.1.</strong> Mutability</a></li><li><a href="./named-arguments.html"><strong>4.2.</strong> Named arguments</a></li><li><a href="./return.html"><strong>4.3.</strong> Return</a></li></ul></li><li><a href="./blocks.html"><strong>5.</strong> Blocks</a></li><li><a href="./variables.html"><strong>6.</strong> Variables</a></li><li><ul class="section"><li><a href="./numbers.html"><strong>6.1.</strong> Numbers</a></li><li><a href="./strings.html"><strong>6.2.</strong> Strings</a></li><li><a href="./booleans.html"><strong>6.3.</strong> Booleans</a></li><li><a href="./4d-vectors.html"><strong>6.4.</strong> 4D vectors</a></li><li><a href="./arrays.html"><strong>6.5.</strong> Arrays</a></li><li><a href="./objects.html"><strong>6.6.</strong> Objects</a></li><li><a href="./links.html"><strong>6.7.</strong> Links</a></li><li><a href="./closures.html"><strong>6.8.</strong> Closures</a></li><li><a href="./options.html"><strong>6.9.</strong> Options</a></li><li><a href="./results.html"><strong>6.10.</strong> Results</a></li><li><a href="./threads.html"><strong>6.11.</strong> Threads</a></li><li><a href="./secrets.html"><strong>6.12.</strong> Secrets</a></li></ul></li><li><a href="./if.html"><strong>7.</strong> If</a></li><li><a href="./loops.html"><strong>8.</strong> Loops</a></li><li><ul class="section"><li><a href="./break.html"><strong>8.1.</strong> Break</a></li><li><a href="./continue.html"><strong>8.2.</strong> Continue</a></li><li><a href="./infer-range.html"><strong>8.3.</strong> Infer range</a></li><li><a href="./packed-loops.html"><strong>8.4.</strong> Packed loops</a></li></ul></li><li><a href="./current-objects.html"><strong>9.</strong> Current objects</a></li><li><a href="./types.html"><strong>10.</strong> Types</a></li><li><ul class="section"><li><a href="./ad-hoc-types.html"><strong>10.1.</strong> Ad-hoc types</a></li><li><a href="./complain-when-wrong.html"><strong>10.2.</strong> Complain when wrong</a></li></ul></li><li><a href="./lifetimes.html"><strong>11.</strong> Lifetimes</a></li><li><a href="./error-handling.html"><strong>12.</strong> Error handling</a></li><li><a href="./copy-on-write.html"><strong>13.</strong> Copy-on-write</a></li><li><a href="./dynamic-modules.html"><strong>14.</strong> Dynamic modules</a></li><li><a href="./look-up-functions.html"><strong>15.</strong> Look up functions</a></li><li><a href="./optimize-performance.html"><strong>16.</strong> Optimize performance</a></li><li><a href="./interop-with-rust.html"><strong>17.</strong> Interop with Rust</a></li><li><ul class="section"><li><a href="./lib-dyon.html"><strong>17.1.</strong> lib.dyon</a></li><li><a href="./mutability-interop.html"><strong>17.2.</strong> Mutability interop</a></li><li><a href="./lifetime-interop.html"><strong>17.3.</strong> Lifetime interop</a></li><li><a href="./manual-interface.html"><strong>17.4.</strong> Manual interface</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Dyon Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Introduction</h1>
<p>Welcome to the Dyon 0.21 tutorial!</p>
<p>Dyon is a dynamically typed scripting language,
designed for game engines and interactive applications.
It was started in 2016 by Sven Nilsen.</p>
<p>This tutorial is written for people with little programming experience.
The language is made simple on purpose.
If you are experienced programmer, you might want to skip to the parts that interests you.</p>
<h3>Dyon is different!</h3>
<p>If you have used another programming language before,
there are some things worth to keep in mind:</p>
<p>Dyon has a limited memory model because of the lack of a garbage collector.
The language is designed to work around this limitation.</p>
<p>The language takes ideas from Javascript, Go and Rust, but focuses on practical features for making games:</p>
<ul>
<li>Optional type system with ad-hoc types</li>
<li>Similar object model to Javascript, but without <code>null</code></li>
<li>Built-in support for 4D vectors, HTML hex colors</li>
<li>Go-like coroutines</li>
</ul>
<p>There are plenty of new ideas in Dyon:</p>
<ul>
<li>Lifetime check for function arguments</li>
<li>Use <code>return</code> as local variable</li>
<li>Mathematical loops</li>
<li>Current objects</li>
<li>Secrets</li>
<li>Grab expressions</li>
<li>Dynamic modules as a way of organizing code</li>
</ul>
<h3>How this tutorial is organized</h3>
<p>At the bottom there is a &quot;Comments&quot; section.
This contains things you might have noticed and things you can try out on your own.</p>
<h3>Source code</h3>
<p>You will find the source code for all examples under &quot;examples&quot; in the <a href="https://github.com/pistondevelopers/dyon-tutorial">git repository</a>.</p>
<h1>Getting started</h1>
<p>Before you can run Dyon programs, you need to do the following:</p>
<ol>
<li>Install <a href="https://www.rust-lang.org/en-US/">Rust</a>.</li>
<li>Open up the Terminal window</li>
<li>Type <code>cargo new --bin &lt;project name&gt;</code></li>
</ol>
<p>Open up &quot;Cargo.toml&quot; and add the following:</p>
<pre><code>[dependencies]
dyon = &quot;0.21.0&quot;
</code></pre>
<p>Open up &quot;src/main.rs&quot; and type:</p>
<pre><code class="language-rust">extern crate dyon;

use dyon::{error, run};

fn main() {
    error(run(&quot;src/main.dyon&quot;));
}
</code></pre>
<h3>Hello World example</h3>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/hello_world">examples/hello_world</a></p>
<p>Put this in &quot;src/main.dyon&quot;:</p>
<pre><code class="language-rust">fn main() {
    println(&quot;Hello world!&quot;)
}
</code></pre>
<p>In the terminal window, go to the &quot;hello_world&quot; folder and type:</p>
<pre><code>$ cargo run
</code></pre>
<p>This should print out:</p>
<pre><code>Hello world!
</code></pre>
<h3>Comments</h3>
<p>You might have noticed:</p>
<ul>
<li>Dyon has no &quot;;&quot; at the end of lines</li>
<li>The &quot;fn&quot; keyword is used by both Rust and Dyon</li>
<li>The &quot;main&quot; function is called when running the program</li>
<li>Double quotes &quot;&quot; are used for text</li>
</ul>
<p>Some things you can try:</p>
<ol>
<li>Put your name inside the text!</li>
<li>Add a new line where you print out something else!</li>
<li>Change &quot;println&quot; to &quot;print&quot; and see what happens!</li>
</ol>
<h1>Comments</h1>
<p>A comment is text to explain how some code works.
Comments are ignored when running the program.</p>
<p>Dyon uses <code>//</code> for single-line and <code>/* */</code> for multi-line comments.</p>
<pre><code class="language-rust">/*

This text is inside a multi-line comment.
It is ignored when running the program.

*/

fn main() {
    // Can I ask you something?
    println(&quot;hello?&quot;)
}
</code></pre>
<p>A single-line comment ignores the rest of the line:</p>
<pre><code class="language-rust">println(&quot;hello&quot;) // Prints `hello`.
</code></pre>
<p>A multi-line comment starts with <code>/*</code> and ends with <code>*/</code>.</p>
<pre><code class="language-rust">/* testing, testing! */
println(&quot;hello&quot;)
</code></pre>
<p>You can nest <code>/* */</code>:</p>
<pre><code class="language-rust">/*
    /*
    A comment inside a comment!
    */
*/
</code></pre>
<h3>Tips and tricks</h3>
<p>It is more common to use <code>//</code> than <code>/* */</code> for documenting the code.</p>
<p>End a comment with a dot to make it easier to see where the line is ending:</p>
<pre><code class="language-rust">// Alice opened the door
// by pressing a button.
</code></pre>
<p>You can use <code>/* */</code> to ignore some code without removing it:</p>
<pre><code class="language-rust">/*
fn main() {
    println(&quot;one&quot;)
}
*/

fn main() {
    println(&quot;two&quot;)
}
</code></pre>
<p>One technique that helps making code more understandable:
Organize the code in paragraphs, like in a book.
Write a single-line comment for each paragraph.
Separate paragraphs with an empty line.</p>
<pre><code class="language-rust">fn main() {
    // Print the numbers from 1 to 10.
    list := sift i 10 { i + 1 }
    println(list)

    // Print the numbers from 11 to 20.
    list := sift i [10, 20) { i + 1 }
    println(list)
}
</code></pre>
<h1>Functions</h1>
<p>In Dyon, there are two ways to declare a function.</p>
<p>One way is to use <code>fn</code> to define a function:</p>
<pre><code class="language-rust">fn f(x) -&gt; {
    return x + 1
}
</code></pre>
<p>If a function does not return a value, you leave out <code>-&gt;</code>:</p>
<pre><code class="language-rust">fn say_hi() {
    println(&quot;hi!&quot;)
}
</code></pre>
<p>Another way is to use mathematical notation:</p>
<pre><code class="language-rust">f(x) = x + 1
</code></pre>
<p>All mathematically declared functions returns a value.</p>
<p>Pro tip: To declare constants, use mathematical notation:</p>
<pre><code class="language-rust">// Speed of light.
c() = 299_792_458
</code></pre>
<h3>Fibonacci example</h3>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/fibonacci">examples/fibonacci</a></p>
<pre><code class="language-rust">fib(x) = if x &lt;= 0 { 0 }
         else if x == 1 { 1 }
         else { fib(x-1) + fib(x-2) }

fn main() {
    for i 20 { println(fib(i)) }
}
</code></pre>
<p>Do not worry if you do not understand the code above.
This is just to show how to declare a function and call it.</p>
<h1>Mutability</h1>
<p>In Dyon, when a function changes an argument, you need to add <code>mut</code>:</p>
<pre><code class="language-rust">fn foo(mut x) {
    x = 3
}

fn main() {
    a := 2
    foo(mut a)
    println(a) // prints `3`
}
</code></pre>
<p>A function that calls a function that changes an argument, also need <code>mut</code>:</p>
<pre><code class="language-rust">fn foo(mut x) {
    x = 3
}

// Requires `mut x` because it calls `foo`.
fn bar(mut x) {
    foo(mut x)
}

fn main() {
    a := 2
    bar(mut a)
    println(a) // prints `3`
}
</code></pre>
<p>This helps programmers understand the code.</p>
<p>Mutability information is part of the function name.
You can declare multiple functions with different mutability patterns:</p>
<pre><code class="language-rust">// `name`
name(person: {}) = clone(person.name)

// `name(mut,_)`
fn name(mut person, name) {
    person.name = clone(name)
}

fn main() {
    character := {name: &quot;Homer Simpson&quot;}
    println(name(character)) // prints `Homer Simpson`
    name(mut character, &quot;Marge Simpson&quot;)
    println(name(character)) // prints `Marge Simpson`
}
</code></pre>
<h1>Named arguments</h1>
<p>In Dyon, you can call some functions in two ways:</p>
<pre><code class="language-rust">attack__player_enemy(mut player, enemy)
attack(player: mut player, enemy: enemy)
</code></pre>
<p>The named arguments are part of the function name.</p>
<ul>
<li>Double underscores separates function name from arguments</li>
<li>Arguments are separated by a single underscore</li>
</ul>
<p>It is common to use named arguments when there are lots of parameters.</p>
<h1>Return</h1>
<p>In Dyon, <code>return</code> can be used as a variable:</p>
<pre><code class="language-rust">fn foo(mut a: f64) -&gt; {
    return = a + 2
    a += 2
}
</code></pre>
<p>If you leave out <code>=</code>, the function will exit with the value:</p>
<pre><code class="language-rust">fn foo(a: f64) -&gt; {
    return a + 2
    println(&quot;hi&quot;) // never gets called.
}
</code></pre>
<p>Functions without <code>-&gt;</code> can use <code>return</code> without a value:</p>
<pre><code class="language-rust">fn foo() {
    return
}
</code></pre>
<p>All functions that returns a value must use <code>return</code>.
You get an error if you forget it:</p>
<pre><code class="language-rust">fn foo(a: f64) -&gt; { a + 2 } // ERROR
</code></pre>
<pre><code>--- ERROR ---
In `source/test.dyon`:

Type mismatch (#775):
Expected `any`, found `void`
1,1: fn foo(a: f64) -&gt; { a + 2 }
1,1: ^
</code></pre>
<h1>Blocks</h1>
<p>A block starts with <code>{</code> and ends with <code>}</code>:</p>
<pre><code class="language-rust">a := {
    println(&quot;hi!&quot;)
    5
}
println(a) // prints `5`
</code></pre>
<p>The last expression in a block becomes the result of block expression.</p>
<p>When declaring a variable inside a block, you might get an error:</p>
<pre><code class="language-rust">a := {
    b := 5
    b // ERROR
}
</code></pre>
<pre><code>--- ERROR ---
In `source/test.dyon`:

`b` does not live long enough
2,10:     a := {
2,10:          ^
3,1:         b := 5
4,1:         b // ERROR
5,1:     }
</code></pre>
<p>Dyon has no garbage collector, but uses a lifetime checker instead.
This is explained later in the chapter &quot;Lifetimes&quot;.</p>
<p>This means that &quot;b&quot; only lives for the scope of the block,
and you must use <code>clone</code> to fix it:</p>
<pre><code class="language-rust">a := {
    b := 5
    clone(b) // OK
}
</code></pre>
<p>When you do a math operation, Dyon knows it is safe:</p>
<pre><code class="language-rust">a := {
    b := 5
    b + 2 // OK
}
</code></pre>
<h1>Variables</h1>
<pre><code class="language-rust">a := 3 // Create a variable &quot;a&quot; with value `3`.
a = 4 // Change the value of variable &quot;a&quot; to `4`.
</code></pre>
<p>A variable has a name, a type and a value.</p>
<ul>
<li>The operator <code>:=</code> creates a variable.</li>
<li>The operator <code>=</code> changes the value of a variable.</li>
</ul>
<p>When changing the value of a variable, the type must be the same:</p>
<pre><code class="language-rust">a := 3
a = &quot;hi!&quot; // ERROR
</code></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)

Expected assigning to text
3,5:     a = &quot;hi!&quot; // ERROR
3,5:     ^
</code></pre>
<h3>Echo example</h3>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/echo">examples/echo</a></p>
<p>Create a new project and name it &quot;echo&quot;.</p>
<p>Put this in &quot;src/main.dyon&quot;:</p>
<pre><code class="language-rust">fn main() {
    print(&quot;Type something: &quot;)
    line := read_line()
    sleep(1)
    println(line)
}
</code></pre>
<p>This program prints out the text you gave it after 1 second.
The text is stored inside a variable &quot;line&quot;.</p>
<h3>Comments</h3>
<p>You might have noticed:</p>
<ul>
<li><code>println</code> ends with a new line, while <code>print</code> stays at same line</li>
</ul>
<p>Some things you can try:</p>
<ol>
<li>Print out &quot;You said: (line)&quot;!</li>
<li>Change <code>sleep(1)</code> to wait 5 seconds!</li>
<li>Change the name of &quot;line&quot; to something else!</li>
<li>Put &quot;println(line)&quot; first and see what happens!</li>
</ol>
<h1>Numbers</h1>
<p>A number in Dyon is a variable that stores floats with 64 bit precision.
The type is <code>f64</code>.</p>
<pre><code class="language-rust">a := 1
b := .5
c := 2.5
d := -3
e := 1_000_000
f := 1e6
g := -7_034.52e-22
</code></pre>
<p>You can add, subtract, multiply, divide, take the power and find the division reminder:</p>
<pre><code class="language-rust">a := 2
b := a + 3
c := a - 3
d := a * 3
e := a^3
f := a / 3
g := a % 3
</code></pre>
<h3>Relative change</h3>
<p>The following operators change the value relatively:</p>
<pre><code class="language-rust">a += 1 // increase by 1
a -= 1 // declare by 1
a *= 2 // multiply by 2
a /= 2 // divide by 2
a %= 2 // find division reminder of 2
</code></pre>
<h3>Comments</h3>
<p>Some thing you might have noticed:</p>
<ul>
<li><code>f64</code> is used by both Rust and Dyon</li>
<li>&quot;One million&quot; can be written as <code>1_000_000</code> or <code>1e6</code></li>
</ul>
<h1>Strings</h1>
<p>A string in Dyon is a variable that stores UTF-8 bytes.
This represent text.
The type is <code>str</code>.</p>
<p>Use double quotes to write a string:</p>
<pre><code class="language-rust">a := &quot;hi!&quot;
</code></pre>
<p>The <code>\</code> symbol escapes special characters:</p>
<ul>
<li><code>\n</code> - New line</li>
<li><code>\t</code> - Tab</li>
<li><code>\&quot;</code> - The <code>&quot;</code> character</li>
<li><code>\\</code> - The <code>\</code> character</li>
<li><code>\r</code> - Moves to beginning of line without creating a new line</li>
<li><code>\u005c</code> - Unicode character by 4 hexadecimal code</li>
</ul>
<p>The <code>+</code> operator joins two strings together:</p>
<pre><code class="language-rust">name := &quot;Santa&quot;
title := &quot;hi &quot; + name
</code></pre>
<p>The <code>str</code> function converts a value into a string:</p>
<pre><code class="language-rust">age := 58
println(&quot;Bilbo is &quot; + str(age) + &quot; years old!&quot;)
</code></pre>
<h3>Some useful functions for strings</h3>
<ul>
<li><code>fn str(any) -&gt; str</code> - convert a variable to a string</li>
<li><code>fn read_line() -&gt; str</code> - read line from standard input</li>
<li><code>fn trim(str) -&gt; str</code> - trims away whitespace at both sides</li>
<li><code>fn trim_left(str) -&gt; str</code> - trims away whitespace at left side</li>
<li><code>fn trim_right(str) -&gt; str</code> - trims away whitespace at right side</li>
<li><code>fn json_string(str) -&gt; str</code> - creates a JSON string</li>
<li><code>fn str__color(vec4) -&gt; str</code> - HTML hex color string</li>
<li><code>fn chars(str) -&gt; [str]</code> - characters of a string</li>
</ul>
<h1>Booleans</h1>
<p>A boolean in Dyon is a variable that stores <code>true</code> or <code>false</code>.
This represents a choice with two options.
The type is <code>bool</code>.</p>
<h3>Lazy and eager</h3>
<p>A lazy operator does not compute the right argument if the left argument gives the result.</p>
<p>An eager operator computes both arguments.</p>
<h3>Logical gates</h3>
<p>A logical gate is an operation on two boolean values.</p>
<table><thead><tr><td>A      </td><td>B      </td><td>A AND B</td><td>A OR B</td><td>A XOR B</td><td>A EXC B</td></tr></thead>
<tr><td>false  </td><td>false  </td><td>false  </td><td>false </td><td>false  </td><td>false</td></tr>
<tr><td>false  </td><td>true   </td><td>false  </td><td>true  </td><td>true   </td><td>false</td></tr>
<tr><td>true   </td><td>false  </td><td>false  </td><td>true  </td><td>true   </td><td>true</td></tr>
<tr><td>true   </td><td>true   </td><td>true   </td><td>true  </td><td>false  </td><td>false</td></tr>
</table>
<p>There are 4 operators for AND:</p>
<pre><code class="language-rust">a &amp;&amp; b // lazy
a and b // eager
a ∧ b // eager
a * b // eager
</code></pre>
<p>There are 4 operators for OR:</p>
<pre><code class="language-rust">a || b // lazy
a or b // eager
a ∨ b // eager
a + b // eager
</code></pre>
<p>There is 1 operator for XOR:</p>
<pre><code class="language-rust">a ^ b
</code></pre>
<p>There is 1 operator for EXC:</p>
<pre><code class="language-rust">a - b
</code></pre>
<p>There are 2 operators for NOT:</p>
<pre><code class="language-rust">!a
¬a
</code></pre>
<h3>Why more than one way</h3>
<p>Boolean algebra is used with different notations:</p>
<ul>
<li>Programming applications</li>
<li>Logic</li>
<li>Non-invertible sets</li>
</ul>
<p>When programming applications, you use <code>&amp;&amp;</code>, <code>||</code> and <code>!</code>.</p>
<p>Logic use <code>∧</code>, <code>∨</code> and <code>¬</code>.</p>
<p>Non-invertible sets uses <code>*</code>, <code>+</code> and <code>-</code>.</p>
<p>In the future Dyon might get more features for Boolean algebra.</p>
<h1>4D vectors</h1>
<p>In Dyon, you can compute with 4D vectors:</p>
<pre><code>(x, y, z, w)
</code></pre>
<p>Many operations are built-in for working with 4D vectors:</p>
<pre><code class="language-rust">a := (1, 2, 3, 4)
b := (5, 6, 7, 8)
println(a + b) // prints `(6, 8, 10, 12)`
</code></pre>
<p>The components <code>z</code> and <code>w</code> are set to 0 by default:</p>
<pre><code class="language-rust">a := (1, 2)
</code></pre>
<p>The <code>y</code> component can also be set to 0, but requires &quot;,&quot;:</p>
<pre><code class="language-rust">a := (1,)
</code></pre>
<h3>HTML hex colors</h3>
<p>A HTML hex color is converted into a 4D vector:</p>
<pre><code>a := #ff0000 // red
b := #00ff00 // green
c := #0000ff // blue
d := #00000033 // semi-transparent black
</code></pre>
<h3>Swizzle components</h3>
<p>To swizzle components, you can use this notation:</p>
<pre><code class="language-rust">a := (1, 2)
b := (yx a,)
</code></pre>
<p>You can repeat a component up to 4 times:</p>
<pre><code class="language-rust">a := (1, 2)
b := (yyyy a,)
println(b) // prints `(2, 2, 2, 2)`
</code></pre>
<h3>Calling functions</h3>
<p>When calling a function, you can unpack vector components:</p>
<pre><code class="language-rust">add(x, y) = x + y

fn main() {
    a := (1, 2)
    println(add(xy a)) // prints `3`
}
</code></pre>
<p>If a function takes named arguments, you can use this trick:</p>
<pre><code class="language-rust">add__x_y(x, y) = x + y

fn main() {
    a := (1, 2)
    println(add(x_y: xy a)) // prints `3`
}
</code></pre>
<h3>Addition and multiplication</h3>
<p>Addition and multiplication is per component for two vectors.</p>
<pre><code class="language-rust">(1, 2) + (3, 4) // `(4, 6)`
(1, 2) * (3, 4) // `(3, 8)`
</code></pre>
<p>Scalar addition, multiplication and division is allowed on both sides
and is per component.</p>
<pre><code class="language-rust">(1, 2) + 1 // `(2, 3, 1, 1)`
3 + (1, 2) // `(4, 5, 3, 3)`
(1, 2) * 2 // `(2, 4)`
2 * (1, 2) // `(2, 4)`
(1, 2) / 2 // `(0.5, 1)`
2 / (1, 2, 4, 8) // `(2, 1, 0.5, 0.25)`
</code></pre>
<h3>Dot product</h3>
<p>Dot product of two vectors can be written in two ways:</p>
<pre><code class="language-rust">a := (1, 2)
b := (3, 4)
println(a *. b)
println(a · b)
</code></pre>
<h3>Cross product</h3>
<p>Cross product of two vectors can be written in two ways:</p>
<pre><code class="language-rust">a := (1, 2)
b := (3, 4)
println(a x b)
println(a ⨯ b)
</code></pre>
<h3>Norm</h3>
<p>The norm of a vector, also called &quot;length&quot; or &quot;magnitude&quot;:</p>
<pre><code class="language-rust">a := (3, 4)
println(|a|)
</code></pre>
<h3>Un-loops</h3>
<p>The <code>vec4</code>, <code>vec3</code>, <code>vec2</code> are un-rolled and replaces the index with a number:</p>
<pre><code class="language-rust">fn main() {
    a := vec4 i { i + 1 }
    println(a) // prints `(1, 2, 3, 4)`
}
</code></pre>
<p>You can check this by printing out a closure:</p>
<pre><code class="language-rust">fn main() {
    a := \() = vec4 i { i + 1 }
    // prints `\() = ({ 0 + 1 }, { 1 + 1 }, { 2 + 1 }, { 3 + 1 })`
    println(a)
}
</code></pre>
<h3>Other functions for 4D vectors:</h3>
<ul>
<li><code>fn x(vec4) -&gt; f64</code> - get x component</li>
<li><code>fn y(vec4) -&gt; f64</code> - get y component</li>
<li><code>fn z(vec4) -&gt; f64</code> - get z component</li>
<li><code>fn w(vec4) -&gt; f64</code> - get w component</li>
<li><code>fn s(vec4, f64) -&gt; f64</code> - get vector component by index</li>
<li><code>fn dir__angle(f64) -&gt; vec4</code> - rotation vector around Z axis</li>
</ul>
<h3>Precision</h3>
<p>Whenever you do calculations with 4D vectors, you get float 32 bit precision.</p>
<h1>Arrays</h1>
<p>An array stores a list of values. The type is <code>[]</code>.</p>
<pre><code class="language-rust">a := [1, 2, 3]
</code></pre>
<p>You can store values of different types in the same array:</p>
<pre><code class="language-rust">a := [1, &quot;hi&quot;, [1, 2, 3]]
</code></pre>
<p>To access an value inside an array, you use a number that start at <code>0</code>:</p>
<pre><code class="language-rust">a := [1, 2, 3]
println(a[0]) // prints `1`
println(a[1]) // prints `2`
println(a[2]) // prints `3`
</code></pre>
<h3>Multi-dimensional arrays</h3>
<p>An array can contain arrays.
This makes it possible to represent grids in 2D, 3D etc.</p>
<pre><code class="language-rust">a := [1, 2, 3] // 1D
println(a[0]) // prints `1`

b :=  [ // 2D
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
println(b[0][0]) // prints `1`

c :=  [ // 3D
          [[1, 2], [3, 4]],
          [[5, 6], [7, 8]],
      ]
println(a[0][0][0]) // prints `1`
</code></pre>
<h3>Memory</h3>
<p>Each item in an array takes 24 bytes (64 bit platforms):</p>
<ul>
<li>8 bytes for type information</li>
<li>16 bytes for item data</li>
</ul>
<p>This is optimized to store 4D vectors.</p>
<h1>Objects</h1>
<p>An object stores a list of values, organized as a dictionary. The type is <code>{}</code>.</p>
<pre><code class="language-rust">a := {x: 1, y: &quot;hi&quot;}
</code></pre>
<p>To change a value in an object:</p>
<pre><code class="language-rust">a.x = 2
</code></pre>
<p>Alternative:</p>
<pre><code class="language-rust">a[&quot;x&quot;] = 2
</code></pre>
<p>The value must be of the same type.</p>
<p>If you want to change the type, use <code>:=</code>:</p>
<pre><code class="language-rust">a.x := &quot;hi!&quot;
</code></pre>
<p>Insert new keys and values with <code>:=</code>:</p>
<pre><code class="language-rust">a := {}
a.x := 1
a.y := 2
a.z := 3
</code></pre>
<h3>Some useful functions</h3>
<ul>
<li><code>fn has({}, str) -&gt; bool</code> - return <code>true</code> if object has key</li>
<li><code>fn keys({}) -&gt; [str]</code> - return keys of object</li>
</ul>
<h1>Links</h1>
<p>A link in Dyon is a variable that stores <code>bool</code>, <code>f64</code> and <code>str</code> efficiently.
It is called &quot;link&quot; because it is fast and easy to put together data.</p>
<pre><code class="language-rust">name := &quot;John&quot;
a := link {&quot;Hi &quot;name&quot;!&quot;}
</code></pre>
<p>The data inside a link can not be changed.
You can read the data using <code>head</code> and <code>tail</code>:</p>
<pre><code class="language-rust">a := link { 1 2 3 }
b := head(a) // `some(1)`
c := tail(a) // `link { 2 3 }`
</code></pre>
<p>When you put a link inside a link, it gets flattened:</p>
<pre><code class="language-rust">a := link { 1 2 3 }
// `link { &quot;start &quot;1 2 3&quot; end&quot; }`
b := link { &quot;start &quot;a&quot; end&quot; }
</code></pre>
<h3>When to use links</h3>
<p>Links are often used to:</p>
<ul>
<li>Generate lots of data and then convert to <code>str</code></li>
<li>Pre-process parts of a text template</li>
<li>Generate a web page</li>
<li>Code generation</li>
<li>Store lots of <code>f64</code>, <code>bool</code> or <code>str</code> in memory</li>
</ul>
<p>Because of the easy syntax for links, you can use Dyon as a template language.</p>
<h3>Memory</h3>
<p>The memory of a link is divided into blocks of 1024 bytes (64 bit platforms).</p>
<p>A link takes only 3.2% extra memory than the ideal amount when blocks are filled.</p>
<p>To save memory with a link compared to an array, you need 42 items:</p>
<pre><code class="language-rust">a := link {
        0 1 2 3 4 5 6 7 8
        9 10 11 12 13 14 15 16
        17 18 19 20 21 22 23 24
        25 26 27 28 29 30 31 32
        33 34 35 36 37 38 39 40
        41 42
    }
</code></pre>
<h3>Other operators</h3>
<p>You can use <code>+=</code> (back) and <code>-=</code> (front) to link together link blocks.
This is faster, but uses a little more memory.</p>
<p>You can not use <code>+</code> because it is too easy to waste memory by error.</p>
<h3>Some useful functions</h3>
<ul>
<li><code>fn is_empty(link) -&gt; bool</code> - return <code>true</code> if link is empty</li>
<li><code>fn head(link) -&gt; opt[any]</code> - return first item in link</li>
<li><code>fn tail(link) -&gt; link</code> - return whole link except first item</li>
<li><code>fn tip(link) -&gt; opt[any]</code> - return last item in link</li>
<li><code>fn neck(link) -&gt; link</code> - return whole link except last item</li>
</ul>
<h1>Closures</h1>
<p>A closure in Dyon is a variable that works similar to a mathematical function.</p>
<pre><code class="language-rust">a := \(x) = x + 1
</code></pre>
<p>You can print out a closure:</p>
<pre><code class="language-rust">// prints `\(x: any) = x + 1`
println(\(x) = x + 1)
</code></pre>
<p>To call a closure, use the <code>\</code> character before the name:</p>
<pre><code class="language-rust">a := \(x) = x + 1
println(\a(0)) // prints `1`
</code></pre>
<h3>Calling closures on objects</h3>
<p>When an object stores a closure, you can call it with named arguments:</p>
<pre><code class="language-rust">fn main() {
    gollum := {say__msg: \(msg) = &quot;My precious &quot; + msg}
    // prints `my precious ring`
    println(\gollum.say(msg: &quot;ring&quot;))
}
</code></pre>
<h3>Grab</h3>
<p>Use <code>grab</code> to compute a value and insert it into a closure:</p>
<pre><code class="language-rust">a := 2
b := \(x) = (grab a + 2) + x
// prints `\(x: any) = 4 + x`
println(b)
</code></pre>
<p>When a closure is inside another closure, you can use <code>grab '2</code>:</p>
<pre><code class="language-rust">a := 2
b := \(x) = \(y) = (grab '2 a) + (grab x) + y
// prints `\(x: any) = \(y: any) = 2 + (grab x) + y`
println(b)
// prints `\(y: any) = 2 + 0 + y`
println(\b(0))
</code></pre>
<p>You can use <code>grab 'N</code> where <code>N</code> is the level you want to compute from.</p>
<p>Pro tip: Pre-compute as much as possible with <code>grab</code> to improve performance.</p>
<h1>Options</h1>
<p>In Dyon, optional values are wrapped in <code>some(x)</code> or <code>none()</code>.
The type is <code>opt</code>, which defaults to <code>opt[any]</code>.</p>
<p>The <code>unwrap</code> function returns the value inside <code>some(x)</code>.</p>
<pre><code class="language-rust">fn main() {
    a := some(5)
    if a != none() {
        println(unwrap(a)) // prints `5`
    }
}
</code></pre>
<h3>Note to programmers accustomed to <code>null</code></h3>
<p>Many languages uses <code>null</code> or <code>nil</code> to indicate an empty reference.
This leads to lots of maintenance problems, because it can appear anywhere.</p>
<p>Dyon uses <code>opt</code> whenever you would use <code>null</code> in another language.
This forces programmers to deal with it explicitly,
which reduces number of bugs in the program.</p>
<h3>Some useful functions</h3>
<ul>
<li><code>fn some(any) -&gt; opt[any]</code></li>
<li><code>fn none() -&gt; opt[any]</code></li>
<li><code>fn unwrap(any) -&gt; any</code></li>
</ul>
<h1>Results</h1>
<p>In Dyon, results are wrapped in <code>ok(x)</code> or <code>err(x)</code>.
The type is <code>res</code> which defaults to <code>res[any]</code>.
The error type is always <code>any</code>.</p>
<pre><code class="language-rust">fn main() {
    a := ok(5)
    if is_ok(a) {
        println(unwrap(a)) // prints `5`
    }
}
</code></pre>
<p>Result is used to handle errors explicitly.
Dyon has an operator <code>?</code> to make this easier.
You can read more about this in the chapter &quot;Error handling&quot;.</p>
<h3>Some useful functions</h3>
<ul>
<li><code>fn unwrap(any) -&gt; any</code></li>
<li><code>fn unwrap_err(any) -&gt; any</code></li>
<li><code>fn is_ok(res[any]) -&gt; bool</code></li>
<li><code>fn is_err(res[any]) -&gt; bool</code></li>
<li><code>fn ok(any) -&gt; res[any]</code></li>
<li><code>fn err(any) -&gt; res[any]</code></li>
</ul>
<h1>Threads</h1>
<p>In Dyon, a thread is created with the <code>go</code> keyword.
The type is <code>thr</code>, which defaults to <code>thr[any]</code>.</p>
<pre><code class="language-rust">fn find_sum(n: f64) -&gt; f64 {
    return sum i n { i + 1 }
}

fn main() {
    a := go find_sum(1_000_000)
    println(unwrap(join(thread: a))) // prints `500000500000`
}
</code></pre>
<p>A thread runs in parallel.</p>
<h3>Current objects are not passed between threads</h3>
<p>Dyon does a clone of variables that are passed to a <code>go</code> call.
The new thread starts with an empty stack.
This means that current objects are not shared between threads.</p>
<h3>There can only be one reference when joining</h3>
<p>A thread must only have a single reference to it when joining.
For example, if you store threads in an an array, you need to use <code>pop</code>.</p>
<p>Source code: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/multi_threads">examples/multi_threads</a></p>
<pre><code class="language-rust">foo(i) = i + 40

fn main() {
    a := sift i 3 {go foo(i)}
    for i len(a) {
        println(unwrap(join(thread: pop(mut a))))
    }
}
</code></pre>
<h3>Some useful functions</h3>
<ul>
<li><code>fn join__thread(thr[any]) -&gt; res[any]</code> - waits for the thread to finish, then returns the result</li>
</ul>
<h1>Secrets</h1>
<p>In Dyon, a secret is a hidden array of values associated with a <code>bool</code> or <code>f64</code>.
The type if <code>sec[bool]</code> or <code>sec[f64]</code>.</p>
<p>Use <code>explain_why</code> to add a secret to a <code>bool</code>:</p>
<pre><code class="language-rust">a := explain_why(true, &quot;hi!&quot;)
if a {
    println(why(a)) // prints `[&quot;hi!&quot;]`
}
</code></pre>
<p>Use <code>explain_where</code> to add a secret to a <code>f64</code>:</p>
<pre><code class="language-rust">a := explain_where(2.5, &quot;giant&quot;)
println(where(a)) // prints `[&quot;giant&quot;]`
</code></pre>
<p>A secret propagates from the left argument of a binary operator:</p>
<pre><code class="language-rust">a := explain_where(2.5, &quot;giant&quot;)
is_tall := a &gt; 2.0
if is_tall {
    println(why(is_tall)) // prints `[&quot;giant&quot;]`
}
</code></pre>
<p>When using a <code>min</code>, <code>max</code>, <code>any</code> or <code>all</code>, the indices are automatically added as secrets:</p>
<pre><code class="language-rust">list := [[1, 2], [3, 4]]
println(why(any i, j { list[i][j] &gt; 2 })) // prints `[1, 0]`
</code></pre>
<h3>A secret must have meaning</h3>
<p>The function <code>why</code> will only work if the value is <code>true</code>.
This prevents programs that do not make sense, such as:</p>
<pre><code class="language-rust">list := [1, 2, 3]
println(why(all i { list[i] &lt; 10 }))
</code></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)
why

This does not make sense, perhaps an array is empty?
3,17:     println(why(all i { list[i] &lt; 10 }))
3,17:                 ^
</code></pre>
<p>Likewise, <code>where</code> will only work if the value is not <code>NaN</code> (0/0):</p>
<pre><code class="language-rust">list := []
println(where(min i { list[i] }))
</code></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)

This does not make sense, perhaps an array is empty?
3,19:     println(where(min i { list[i] }))
3,19:                   ^
</code></pre>
<p>Remember to check for empty arrays!</p>
<h1>If</h1>
<p>In Dyon, the <code>if</code> keyword runs a block if its condition is true:</p>
<pre><code class="language-rust">a := 3 &lt; 4
if a {
    println(&quot;hi!&quot;)
}
</code></pre>
<p>An <code>else</code> block runs when previous conditions are false:</p>
<pre><code class="language-rust">a := 3 &gt; 4
if a {
    println(&quot;yes!&quot;)
} else {
    println(&quot;no...&quot;)
}
</code></pre>
<p>An <code>else if</code> block runs when previous conditions are false and its condition is true:</p>
<pre><code class="language-rust">a := 2
if a == 0 {
    println(&quot;=0&quot;)
} else if a == 1 {
    println(&quot;=1&quot;)
} else if a == 2 {
    println(&quot;=2&quot;)
} else {
    println(&quot;&gt;2&quot;)
}
</code></pre>
<p>An <code>if</code> can be used as an expression:</p>
<pre><code class="language-rust">a := 3
b := 3
c := 2 + if a == b { 1 } else { 0 }
</code></pre>
<h1>Loops</h1>
<p>In Dyon there are 4 kinds of loops:</p>
<ul>
<li>Infinite loop</li>
<li>Traditional For loop</li>
<li>Mathematical loops</li>
<li>Link loop</li>
</ul>
<h3>Infinite loop</h3>
<pre><code class="language-rust">loop {
    println(&quot;hi!&quot;)
    sleep(1)
}
</code></pre>
<p>An infinite loop runs runs forever, or until <code>break</code> is used inside it.</p>
<p>Tip: Use Ctrl+C to terminate an infinite loop in the Terminal window.</p>
<h3>Traditional For loop</h3>
<pre><code class="language-rust">for i := 0; i &lt; 10; i += 1 {
    println(i)
}
</code></pre>
<p>A traditional loop is similar to the loop in the programming language C.
It takes 3 expressions:</p>
<ul>
<li>Initialize, called first and once, e.g. <code>i := 0</code></li>
<li>Condition, checked for each turn, e.g. <code>i &lt; 10</code></li>
<li>Step, called after each turn, e.g. <code>i += 1</code></li>
</ul>
<h3>Mathematical loops</h3>
<p>Dyon is famous for its mathematical loops:</p>
<ul>
<li><code>for</code> - do something for each turn</li>
<li><code>sift</code> - create an array out of values</li>
<li><code>min</code> - find the minimum value</li>
<li><code>max</code> - find the maximum value</li>
<li><code>∃</code>/<code>any</code> - check whether a condition is true for any value</li>
<li><code>∀</code>/<code>all</code> - check whether a condition is true for all values</li>
<li><code>∑</code>/<code>sum</code> - add values to get the sum</li>
<li><code>∏</code>/<code>prod</code> - multiply values to get the product</li>
<li><code>∑vec4</code>/<code>sum_vec4</code> - add 4D vectors to get the sum</li>
<li><code>∏vec4</code>/<code>prod_vec4</code> - multiply 4D vectors to get the product</li>
</ul>
<p>In mathematics, it is very common to loop over an index.
An index starts at 0, and increases with 1 for each turn.
All mathematical loops uses the same index notation.</p>
<pre><code class="language-rust">for i 10 {
    println(i)
}
</code></pre>
<p>This is equivalent to <code>for i := 0; i &lt; 10; i += 1</code>.</p>
<p>You can also specify the start and end value:</p>
<pre><code class="language-rust">for i [0, 10) {
    println(i)
}
</code></pre>
<h3>Link loop</h3>
<p>The link loop is similar to a link block, but for a repeated pattern.</p>
<pre><code class="language-rust">list := [1, 2, 3]
println(link i {(i+1)&quot;: &quot;list[i]})
</code></pre>
<p>All evaluated expressions are appended to the link.
Expressions that do not return a value are allowed inside a link loop.</p>
<p>Pro-tip: A link block inside a link loop gives you an all-or-nothing behavior.</p>
<pre><code class="language-rust">ffn main() {
    people := [{name: &quot;Homer&quot;}, {name: &quot;Bart&quot;}, {name: &quot;Marge&quot;}]
    kids := link i {link {
        &quot;name: &quot;
        name := people[i].name
        if name == &quot;Bart&quot; {continue} else {name}
        &quot;\n&quot;
    }}
    print(kids)
}
</code></pre>
<h1>Break</h1>
<p>The <code>break</code> keyword exits a loop:</p>
<pre><code class="language-rust">a := 4
loop {
    a -= 1
    if a &lt; 0 { break }
}
</code></pre>
<p>To exit an outer loop, use a label:</p>
<pre><code class="language-rust">'outer: loop {
    loop {
        break 'outer
    }
}
</code></pre>
<p>In a mathematical loop, <code>break</code> skips the rest:</p>
<pre><code class="language-rust">fn main() {
    list := [1, 2, 3]
    println(sum i {
        if i &gt; 1 { break } // skip `3`
        list[i]
    }) // prints `3`
}
</code></pre>
<h1>Continue</h1>
<p>The <code>continue</code> keyword goes to the next turn.</p>
<pre><code class="language-rust">loop {
    sleep(1)
    continue
    println(&quot;hi&quot;) // never called
}
</code></pre>
<p>To go to the next turn of an outer loop, use a label:</p>
<pre><code class="language-rust">'outer: loop {
    loop {
        continue 'outer
    }
}
</code></pre>
<p>In a mathematical loop, <code>continue</code> skips the current item:</p>
<pre><code class="language-rust">fn main() {
    list := [1, 2, 3, 4]
    println(sum i {
        if i == 2 { continue } // skip `3`
        list[i]
    }) // prints `7`
}
</code></pre>
<h1>Infer range</h1>
<p>In Dyon, the range of a mathematical loop can be inferred from the loop body.</p>
<p>When iterating over a list, you can leave out start and end:</p>
<pre><code class="language-rust">list := [1, 2, 3]

for i {
    println(list[i])
}
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-rust">list := [1, 2, 3]

for i len(list) {
    println(list[i])
}
</code></pre>
<p>For nested loops, the indices must follow the same order as the loops:</p>
<pre><code class="language-rust">list := [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
for i {
    for j {
        for k {
            println(list[i][j][k])
        }
    }
}
</code></pre>
<h1>Packed loops</h1>
<p>In Dyon, you can pack mathematical loops together of the same kind:</p>
<pre><code class="language-rust">for i, j, k {
    println(list[i][j][k])
}
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-rust">for i {
    for j {
        for k {
            println(list[i][j][k])
        }
    }
}
</code></pre>
<p>You can also specify start and end for each index:</p>
<pre><code class="language-rust">fn main() {
    list := [1, 2, 3, 4]
    n := len(list)

    // For each pair.
    for i n, j [i + 1, n) {
        println(abs(list[i] - list[j]))
    }
}
</code></pre>
<p>Pro tip: If you find a packed loop hard to understand,
you can print out closure to see how it works:</p>
<pre><code class="language-rust">fn main() {
    a := \() = {
        list := [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
        for i, j, k {
            println(list[i][j][k])
        }
    }
    println(a)
}
</code></pre>
<h1>Current objects</h1>
<p>In Dyon, a current object is a variable that can be accessed by name.</p>
<p>To create a current object, use <code>~</code> when declaring a variable:</p>
<pre><code class="language-rust">fn main() {
    ~ list := [1, 2, 3]
    print_list()
}

// Get the current object with name `list`.
fn print_list() ~ list {
    for i { println(list[i]) }
}
</code></pre>
<p>A new current object overrides the old one until it runs out of scope:</p>
<pre><code class="language-rust">fn main() {
    ~ a := 2
    foo() // prints `2`
    {
        ~ a := 3
        foo() // prints `3`
    }
    foo() // prints `2`
}

fn foo() ~ a {
    println(a)
}
</code></pre>
<p>Current objects are useful to store things like settings or assets.</p>
<h3>Note to programmers accustomed to globals</h3>
<p>Current objects replaces cases where you would use globals in another language.
Dyon does not support globals, because dynamic modules should not initialize memory upon loading.
A current object is like a global, except you must use it explicitly,
and it has a scope which can replace other current objects.
You might find it much easier to read code using current objects.</p>
<h1>Types</h1>
<p>In Dyon, there are two kinds of types:</p>
<ul>
<li>Runtime types, which only has one level</li>
<li>Static types, which can have more than one level</li>
</ul>
<h3>Runtime types</h3>
<p>Dyon check the runtime type when using <code>=</code> to change a variable.
To get the runtime type, use the <code>typeof</code> function:</p>
<pre><code class="language-rust">fn main() {
    println(typeof(1.2)) // prints `number`
    println(typeof(true)) // prints `boolean`
    println(typeof(&quot;hi!&quot;)) // prints `string`
    println(typeof((1, 2))) // prints `vec4`
    println(typeof([1, 2, 3])) // prints `array`
    println(typeof({a: 2})) // prints `object`
    println(typeof(link { 1 2 3 })) // prints `link`
    println(typeof(some(2))) // prints `option`
    println(typeof(ok(2))) // prints `result`
    println(typeof(go foo())) // prints `thread`
    println(typeof(\(x) = x + 1)) // prints `closure`
    println(typeof(unwrap(load(&quot;src/main.dyon&quot;)))) // prints `rust_object`
}

fn foo() -&gt; { return ok(2) }
</code></pre>
<h3>Static types</h3>
<p>Function arguments can have specify a static type:</p>
<pre><code class="language-rust">fn foo(a: f64) { ... }
</code></pre>
<p>By default this is <code>any</code>.</p>
<p>Static types are used by the type checker to check for errors:</p>
<ul>
<li><code>any</code>, any type</li>
<li><code>f64</code>, number</li>
<li><code>bool</code>, boolean</li>
<li><code>str</code>, string</li>
<li><code>vec4</code>, 4D vector</li>
<li><code>[]</code>, array, defaults to <code>[any]</code></li>
<li><code>{}</code>, object</li>
<li><code>link</code>, link</li>
<li><code>opt</code>, defaults to <code>opt[any]</code></li>
<li><code>res</code>, defaults to <code>res[any]</code></li>
<li><code>thr</code>, defaults to <code>thr[any]</code></li>
<li>Closure type, e.g. <code>\(any, ..) -&gt; any</code></li>
<li>Ad-hoc type, e.g. <code>Foo</code>, defaults to <code>Foo {}</code></li>
</ul>
<p>There is no static type for Rust objects. Use an ad-hoc type, e.g. <code>Foo any</code>.</p>
<h1>Ad-hoc types</h1>
<p>In Dyon, an ad-hoc type is a type that you just give a name.
It is not declared anywhere, but used directly when writing the functions.
Dyon treats ad-hoc types as distinct from each other.</p>
<pre><code class="language-rust">fn new_person(first_name: str, last_name: str) -&gt; Person {
    return {
        first_name: clone(first_name),
        last_name: clone(last_name)
    }
}

fn say_hello(person: Person) {
    println(&quot;Hi &quot; + person.first_name + &quot;!&quot;)
}

fn main() {
    homer := new_person(&quot;Homer&quot;, &quot;Simpson&quot;)
    say_hello(homer) // prints `Hi Homer!`
}
</code></pre>
<p>You can use any name that is not used by other Dyon types.
It is common to use CamelCase.</p>
<p><code>Person</code> is the same as <code>Person {}</code>, where <code>{}</code> is the inner type.</p>
<p>The inner type goes with the ad-hoc type and vice versa:</p>
<pre><code class="language-rust">fn say_hello(person: Person) {
    println(&quot;Hi &quot; + person.first_name + &quot;!&quot;)
}

fn main() {
    say_hello({first_name: &quot;Homer&quot;}) // prints `Hi Homer!`
}
</code></pre>
<h3>Addition and multiplication</h3>
<p>Two ad-hoc types can be added if the inner type allows addition.</p>
<p>Dyon complains if you try to add an ad-hoc type with an inner type.</p>
<p>For example:</p>
<pre><code class="language-rust">// Convert number to `km`
fn km(v: f64) -&gt; km f64 { return v }

km(3) + km(4) // OK
km(3) + 4 // ERROR
</code></pre>
<p>Multiplication is not allowed, because this often changes physical units.</p>
<h1>Complain when wrong</h1>
<p>In Dyon, the type checker only complains when it knows something is wrong.</p>
<p>When you do not specify the type of an argument, it defaults to <code>any</code>:</p>
<pre><code class="language-rust">foo(x) = x + 1

fn main() {
    println(foo(false))
}
</code></pre>
<p>In the program above, the type checker does not know that something is wrong.</p>
<p>You get a runtime error:</p>
<pre><code>--- ERROR ---
main (source/test.dyon)
foo (source/test.dyon)

Invalid type for binary operator `&quot;+&quot;`, expected numbers, vec4s, bools or strings
1,10: foo(x) = x + 1
1,10:          ^
</code></pre>
<p>To get a type error, add the type to the argument:</p>
<pre><code class="language-rust">foo(x: f64) = x + 1
</code></pre>
<p>Now the type checker complains, because it knows that <code>false</code> is not <code>f64</code>:</p>
<pre><code>--- ERROR ---
In `source/test.dyon`:

Type mismatch (#100):
Expected `f64`, found `bool`
4,17:     println(foo(false))
4,17:                 ^
</code></pre>
<h3>Static types are not guaranteed</h3>
<p>The type of an argument is not guaranteed to be the given static type.</p>
<p>For example:</p>
<pre><code class="language-rust">foo(x: f64) = x + 1

forget_type(x: any) = clone(x)

fn main() {
    println(foo(forget_type(false))) // ERROR
}
</code></pre>
<p>This gives you a runtime error, because the type checker is not that smart.</p>
<h1>Lifetimes</h1>
<p>In Dyon, a lifetime tells whether an argument outlives another argument.</p>
<h3>Lifetimes are rare</h3>
<p>In normal programming there is little need to worry about lifetimes.</p>
<p>For example, use <code>clone</code> when putting a variable inside another:</p>
<pre><code class="language-rust">fn put(a, mut b) {
    b[0] = clone(a)
}
</code></pre>
<p>Instead of:</p>
<pre><code class="language-rust">fn put(a: 'b, mut b) {
    b[0] = a
}
</code></pre>
<p>It is useful to know how lifetimes work, but you rarely need them in practice.</p>
<h3>Lifetimes replaces garbage collector</h3>
<p>Some languages can have a pointer to a variable that does not exist.
When this happens, it is called &quot;dangling pointer&quot;.
This can lead to unpredictable behavior and system crashes.
Languages that allow dangling pointer are unsafe,
and the programmer must be extra careful.</p>
<p>Many languages use a garbage collector to avoid dangling pointers.
Instead of removing the variable that the pointer points to,
it keeps it around in memory until all its pointers are gone.</p>
<p>Dyon uses static lifetime checks to ensure that dangling pointers are impossible.
This removes the need for a garbage collector.</p>
<h3>Lifetimes tell the order of declaration</h3>
<p>A lifetime tells whether an argument outlives another argument:</p>
<pre><code class="language-rust">// `a` outlives `b`
fn put(a: 'b, mut b) {
    b[0] = a
}

fn main() {
    a := [2, 3]     // - lifetime of `a`
                    // |
    b := [[]]       // |  - lifetime of `b`
                    // |  |
    put(a, mut b)   // |  |
}
</code></pre>
<p>The variable &quot;a&quot; outlives &quot;b&quot; because it is declared before &quot;b&quot;.</p>
<p>The same program can be written like this:</p>
<pre><code class="language-rust">fn main() {
    a := [2, 3]
    b := [[]]
    b[0] = a
}
</code></pre>
<p>Here, the order of the declared variables is known.</p>
<h3>The <code>return</code> lifetime</h3>
<p>The <code>return</code> lifetime is the lifetime of the <code>return</code> variable.
This outlives the default lifetime of arguments (no lifetime).</p>
<p>If you return one of the argument, you must use <code>'return</code> or <code>clone</code>:</p>
<pre><code class="language-rust">// With `'return` lifetime.
id(x: 'return) = x

// With `clone`.
id(x) = clone(x)
</code></pre>
<h3>The lifetime checker does not understand types</h3>
<p>In Dyon, the static type is not guaranteed at runtime,
therefore <code>bool</code>, <code>f64</code> and <code>str</code> follows same rules as <code>[]</code> or <code>{}</code>:</p>
<pre><code class="language-rust">fn foo(a: f64) -&gt; {
    return a // ERROR
}
</code></pre>
<pre><code>--- ERROR ---
In `source/test.dyon`:

Requires `a: 'return`
2,12:     return a // ERROR
2,12:            ^
</code></pre>
<h3>Lifetimes are about references</h3>
<p>A lifetime is about the references stored inside a variable.
All references outlive variables they are store in.
Variables can not store references to themselves,
because it can not outlive itself.</p>
<p>In order to put a reference inside a variable, the lifetime checker
must know that the reference outlives the variable.</p>
<p>Because of the lifetime checker, all memory in Dyon is an acyclic graph.</p>
<h1>Error handling</h1>
<p>In Dyon, error handling use the <code>?</code> operator to propagate errors.</p>
<pre><code class="language-rust">fn try_divide(a: f64, b: f64) -&gt; res[f64] {
    return if b == 0 { err(&quot;Division by zero&quot;) }
           else { ok(a / b) }
}

fn foo(b: f64) -&gt; res {
    a := try_divide(5, b)?
    return ok(a + 2)
}

fn main() {
    println(foo(2)) // prints `ok(4.5)`
    println(foo(0)) // prints `err(&quot;Division by zero&quot;)`
}
</code></pre>
<p>When using <code>unwrap</code>, an error is reported with a trace of all <code>?</code> operations:</p>
<pre><code class="language-rust">println(unwrap(foo(0)))
</code></pre>
<pre><code>--- ERROR ---
main (source/test.dyon)
unwrap

Division by zero
In function `foo` (source/test.dyon)
7,10:     a := try_divide(5, b)?
7,10:          ^

15,20:     println(unwrap(foo(0)))
15,20:                    ^
</code></pre>
<p>An <code>opt</code> is converted into <code>res</code> when using <code>?</code>,
with the error &quot;Expected <code>some(_)</code>, found `none()&quot;.</p>
<h1>Copy-on-write</h1>
<p>In Dyon, arrays and objects uses atomic reference counting (Arc).</p>
<p>Whenever there are two non-stack references to the same array,
it will create a copy when changing the array:</p>
<pre><code class="language-rust">fn main() {
    // `[1, 2]` is inside an array,
    // and is therefore not stored in stack memory.
    a := [[1, 2]]
    // Create another reference to `[1, 2]`
    b := [a[0]]
    b[0][0] = 3
    println(b[0][0])
    // The old `[1, 2]` array remains unchanged.
    println(a[0][0])
}
</code></pre>
<p>This means that methods, the building-block of OOP patterns, are impossible to use in Dyon:</p>
<pre><code class="language-rust">fn foo(mut a) {
    a[0] = 3
}

fn main() {
    // `[1, 2]` is inside an array,
    // and is therefore not stored in stack memory.
    a := [[1, 2]]
    // When we pass it as argument,
    // the reference counter is increased.
    foo(mut a[0])
    // The value remains unchanged,
    // because `foo` changed a copy.
    println(a[0][0]) // prints `1`
}
</code></pre>
<p>To modify variables inside other variables, it must be declared on the stack:</p>
<pre><code class="language-rust">fn foo(mut a) {
    a[0] = 3
}

fn main() {
    // `[1, 2]` is put on the stack.
    list := [1, 2]
    // Putting a stack reference to `list` inside `a`
    a := [list]
    // When we pass it as argument,
    // the stack reference is passed.
    foo(mut a[0])
    // The value is changed.
    println(a[0][0]) // prints `3`
}
</code></pre>
<h3>Data oriented design</h3>
<p>When writing programs in Dyon, you need to avoid copy-on-write.
The easiest way to do this is to organize application structure in flat arrays.</p>
<ul>
<li>Do not worry about having lots of arrays</li>
<li>Use current objects to pass arrays around</li>
<li>Batch changes to arrays together by iterating over them</li>
</ul>
<p>Optimize the data structure for the algorithms that processes it.
When the algorithm changes, the data structure changes too!</p>
<h3>Dyon is a scripting language</h3>
<p>If you need OOP patterns, then there is only one solution: Use another language, for example Rust.
Dyon is designed for scripting, as in solving problems fast.
It is not designed for building abstractions, or proving things through the type system.</p>
<h1>Dynamic modules</h1>
<p>In Dyon, you organize code by using dynamic modules.
It is common to write a loader script that loads modules and imports them to
other modules.</p>
<h3>Dynmod example</h3>
<p>Source: <a href="https://github.com/PistonDevelopers/dyon-tutorial/tree/master/examples/dynmod">examples/dynmod</a></p>
<p>main.dyon:</p>
<pre><code class="language-rust">fn main() {
    math := unwrap(load(&quot;src/math.dyon&quot;))
    game := unwrap(load(source: &quot;src/game.dyon&quot;, imports: [math]))
    call(game, &quot;main&quot;, [])
}
</code></pre>
<p>math.dyon:</p>
<pre><code class="language-rust">add(a: f64, b: f64) = a + b
</code></pre>
<p>game.dyon:</p>
<pre><code class="language-rust">fn main() {
    a := 2
    b := 3
    println(add(a, b)) // prints `5`
}
</code></pre>
<h3>Calling functions in dynamic modules</h3>
<p>Dyon peforms a runtime lifetime check of arguments for these functions:</p>
<ul>
<li><code>fn call(module, name, args)</code> - returns no value</li>
<li><code>fn call_ret(module, name, args)</code> - returns value</li>
</ul>
<h3>Why dynamic modules?</h3>
<p>Module loading is often an important part of a program:</p>
<ul>
<li>Download updates</li>
<li>Refresh game logic for interactive programming</li>
<li>Swap between backends</li>
</ul>
<p>For example, the same Dyon game can run on game engines that supports multiple backend APIs for rendering.
In other languages you might write generic code to make it reusable across APIs.
Dyon solves this by making all code reusable across APIs, as long as the
dependencies implements the same set of functions.</p>
<h1>Look up functions</h1>
<p>In Dyon, you get all available functions with <code>functions</code>:</p>
<pre><code class="language-rust">fn main() {
    println(functions())
}
</code></pre>
<p>You can write a program that looks up the information about a function:</p>
<pre><code class="language-rust">fn main() {
    fs := functions()
    has_foo := any i { fs[i].name == &quot;foo&quot; }
    if has_foo {
        why := why(has_foo)
        println(fs[why[0]])
    }
}

fn foo() {}
</code></pre>
<pre><code>{returns: &quot;void&quot;, type: &quot;loaded&quot;, arguments: [], name: &quot;foo&quot;}
</code></pre>
<p>Because Dyon uses dynamic modules, <code>functions</code> is the only standard way
of obtaining this information. This can only be known in the loaded module.</p>
<h1>Optimize performance</h1>
<p>To optimize the performance of Dyon programs, compile with <code>cargo build --release</code>.</p>
<p>You can also get further optimization by disabling the default <code>debug_resolve</code> feature.
This compares location of variables on the stack with the static location.
It is not needed for running programs, but used to detect bugs in Dyon.</p>
<p>To disable <code>debug_resolve</code>, change the &quot;Cargo.toml&quot;:</p>
<pre><code>[dependencies.dyon]
version = &quot;0.8.0&quot;
features = []
</code></pre>
<h1>Interop with Rust</h1>
<p>Dyon is designed to work with Rust, but uses different types.</p>
<p>Rust uses static types only, which usually takes up less memory and runs faster.
When you need to high performance, it is recommended to use Rust.</p>
<h3>Functions example</h3>
<p>Source: <a href="https://github.com/PistonDevelopers/dyon/blob/master/examples/functions.rs">dyon/examples/functions.rs</a></p>
<p>The <code>dyon_fn!</code> macro lets you write a Rust function that maps to Dyon types:</p>
<pre><code class="language-rust">#[macro_use]
extern crate dyon;

dyon_fn!{fn say_hello() {
    println!(&quot;hi!&quot;);
}}
</code></pre>
<p>Add the function to a module:</p>
<pre><code class="language-rust">module.add(Arc::new(&quot;say_hello&quot;.into()), say_hello, Dfn {
      lts: vec![],
      tys: vec![],
      ret: Type::Void
  });
</code></pre>
<p>The <code>dyon_obj!</code> macro lets to map new Rust structs to Dyon objects:</p>
<pre><code class="language-rust">pub struct Person {
    pub first_name: String,
    pub last_name: String,
    pub age: u32,
}

dyon_obj!{Person { first_name, last_name, age }}
</code></pre>
<p>All fields must implement <code>embed::PopVariable</code> and <code>embed::PopVariable</code>.</p>
<h3>The <code>Dfn</code> struct</h3>
<p>The <code>Dfn</code> struct describes the type information of the function signature:</p>
<ul>
<li><code>lts</code> - lifetimes, e.g. <code>Lt::Default</code></li>
<li><code>tys</code> - types, e.g. <code>Type::F64</code></li>
<li><code>ret</code> - return type, e.g. <code>Type::Bool</code></li>
</ul>
<p>This is used by the lifetime and type checker when loading modules.</p>
<h1>lib.dyon</h1>
<p>When designing Dyon libraries written in Rust, it is common to include
a &quot;lib.dyon&quot; file in the &quot;src&quot; folder.
This file lists all external functions as they would appear in Dyon code.</p>
<p>Two examples from the Dyon library:</p>
<pre><code class="language-rust">/// Returns an array of derived information for the truth value of `var`.
/// This can be used with the value of `∃`/`any` and `∀`/`all` loops.
fn why(var: bool) -&gt; [any] { ... }

/// Returns an array of derived information for the value of `var`.
/// This can be used with the value of `min` and `max` loops.
fn where(var: f64) -&gt; [any] { ... }
</code></pre>
<p>Comments should start with <code>///</code>.</p>
<h1>Mutability interop</h1>
<p>Mutability information is part of the function name:</p>
<pre><code class="language-rust">fn foo(mut a: f64, b: f64) { ... }
</code></pre>
<p>The name of this function is <code>foo(mut,_)</code>.</p>
<pre><code class="language-rust">module.add(Arc::new(&quot;foo(mut,_)&quot;.into()), foo, Dfn {
      lts: vec![Lt::Default; 2],
      tys: vec![Type::F64; 2],
      ret: Type::Void
  });
</code></pre>
<h1>Lifetime interop</h1>
<p>The <code>Lt</code> enum describes the lifetime of an argument.</p>
<p>The most common lifetime is <code>Lt::Default</code> (no lifetime).</p>
<p>If you have a function like this:</p>
<pre><code class="language-rust">fn foo(mut a: [{}], b: 'a {}) { ... }
</code></pre>
<p>Then the <code>Dfn</code> struct looks like this:</p>
<pre><code class="language-rust">Dfn {
    lts: [Lt::Default, Lt::Arg(0)],
    tys: [Type::Array(Box::new(Type::Object)), Type::Object],
    ret: Type::Void
}
</code></pre>
<p><code>Lt::Arg(0)</code> means the argument outlives the first argument.</p>
<p>Lifetimes must not be cyclic.
For example, this is not valid Dyon code:</p>
<pre><code class="language-rust">fn foo(a: 'b, b: 'a) { ... }
</code></pre>
<p><code>Lt::Return</code> means the arugment outlives the return value:</p>
<pre><code class="language-rust">fn foo(a: 'return) -&gt; { ... }
</code></pre>
<h1>Manual interface</h1>
<p>A manual interface gives more control over the interface between Rust and Dyon.
This is the only way to write external functions that mutate arguments.</p>
<p>The signature of an external function:</p>
<pre><code class="language-rust">fn(rt: &amp;mut Runtime) -&gt; Result&lt;(), String&gt;
</code></pre>
<p>These functions are useful when pushing and popping variables:</p>
<ul>
<li><code>Runtime::pop</code> - convert from stack</li>
<li><code>Runtime::pop_vec4</code> - convert 4D vector from stack</li>
<li><code>Runtime::var</code> - convert from variable</li>
<li><code>Runtime::var_vec4</code> - convert 4D vector from variable</li>
<li><code>Runtime::push</code> - convert to variable on stack</li>
<li><code>Runtime::push_vec4</code> - convert to 4D vector on stack</li>
<li><code>Runtime::resolve</code> - resolve a variable reference</li>
</ul>
<h3>Getting arguments of function</h3>
<p>Since the Dyon runtime uses a stack, you must pop the argument in reverse order.
Before you use an argument, you must use <code>Runtime::resolve</code> in case
it is a reference to a variable:</p>
<pre><code class="language-rust">let draw_list = rt.stack.pop().expect(&quot;There is no value on the stack&quot;);
let arr = rt.resolve(&amp;draw_list);
</code></pre>
<p><code>Runtime::pop</code>, <code>Runtime::pop_var</code>, <code>Runtime::var</code> and <code>Runtime::var_vec4</code>
resolves the variable for you.</p>
<h3>Mutate argument</h3>
<p>To mutate an argument, you need to obtain a mutable reference to the
resolved variable on the stack:</p>
<pre><code class="language-rust">let v = rt.stack.pop().expect(TINVOTS);

if let Variable::Ref(ind) = v {
    let ok = if let Variable::Array(ref mut arr) = rt.stack[ind] {
        Arc::make_mut(arr)...;
    }
}
</code></pre>
<h3>Return value</h3>
<p>After popping argument and computing a value, push the result on the stack.
Do not push more than one value, since Dyon only supports a single return value.</p>
<h3>Reading from a Dyon variable</h3>
<p>The <code>Runtime::var</code> function converts a value inside a variable:</p>
<pre><code class="language-rust">let radius: f64 = try!(rt.var(&amp;it[2]));
</code></pre>
<h3>4D vectors</h3>
<p>The <code>Runtime::var_vec4</code> function converts to a <code>vec4</code> convertible type:</p>
<pre><code class="language-rust">let color: [f32; 4] = try!(rt.var_vec4(&amp;it[1]));
</code></pre>
<h3>Piston-Current</h3>
<p>Dyon keeps no track of variables in the Rust environment.
You can use the <a href="https://github.com/pistondevelopers/current">Piston-Current</a> crate to read from or change such variables by type.</p>
<pre><code class="language-rust">pub fn render(rt: &amp;mut Runtime) -&gt; Result&lt;(), String&gt; {
    rt.push(unsafe { Current::&lt;Option&lt;Event&gt;&gt;::new()
        .as_ref().expect(NO_EVENT).render_args().is_some() });
    Ok(())
}
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
